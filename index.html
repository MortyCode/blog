<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.rcode.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#abc","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="你可以跑,但你不能躲">
<meta property="og:type" content="website">
<meta property="og:title" content="Rick-Code">
<meta property="og:url" content="http://www.rcode.top/index.html">
<meta property="og:site_name" content="Rick-Code">
<meta property="og:description" content="你可以跑,但你不能躲">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="河神">
<meta property="article:tag" content="瑞克和莫蒂">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.rcode.top/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Rick-Code</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Rick-Code</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">日行一步，且得人生半日闲</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

  
    
  <div class="back-to-top">
      <svg t="1610624158144" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2798" width="80" height="80"><path d="M463.04 956.96a177.6 177.6 0 0 1-37.44-3.04c-9.6-2.24-24-6.88-40.64-12.48a447.04 447.04 0 0 0-64-18.08l-16-0.8c-37.44-1.6-84-3.52-86.24-41.76-1.6-28 24.16-69.76 46.24-99.68A224.96 224.96 0 0 1 288 754.72a261.76 261.76 0 0 1-44.8-56.32h-1.6a113.92 113.92 0 0 1-104.16-68.8A102.4 102.4 0 0 1 128 547.52a87.2 87.2 0 0 1 25.6-37.12c-7.52-33.44-20.8-103.84-12-160A210.08 210.08 0 0 1 192 240c9.92-25.44 51.04-106.56 186.08-151.04a473.44 473.44 0 0 1 145.92-22.4c170.72 0 290.72 80 321.12 214.24s27.84 208 21.44 242.24A80 80 0 0 1 896 615.2c-16 55.2-74.72 67.68-102.56 70.56a513.12 513.12 0 0 1-37.76 46.4c-4 4.16-7.84 7.84-11.52 11.2 28.48 25.28 68.8 64 79.2 91.36a90.24 90.24 0 0 1-2.24 71.36 57.44 57.44 0 0 1-29.44 30.08l-2.24 0.8a226.88 226.88 0 0 1-91.36 14.56c-9.92 0-20.64 0-32-1.12-24.8-1.6-42.24-3.04-55.52-4.16S588.64 944 581.28 944a128 128 0 0 0-28.16 3.68 480 480 0 0 1-90.08 9.28z" fill="#FFFFFF" p-id="2799"></path><path d="M184.64 522.24s-27.04-97.92-16-167.04a171.84 171.84 0 0 1 47.04-99.2S240 163.36 386.56 115.36s388-23.04 432 172.64 16 250.08 16 250.08A55.2 55.2 0 0 1 870.56 608c-16 52.96-91.04 52-91.04 52A559.04 559.04 0 0 1 736 713.28a126.72 126.72 0 0 1-36 28s84.96 68.96 98.08 103.04-5.92 63.04-15.04 66.08-35.04 18.08-116 12.96-81.92-9.92-120-1.92A368 368 0 0 1 432 928c-21.92-4.96-84-28.96-108-31.04S247.68 896 246.56 880s19.04-52.64 41.44-82.72a167.68 167.68 0 0 1 44-43.04 211.36 211.36 0 0 1-72.96-84.96s-61.92 16.96-96.96-52 22.56-95.04 22.56-95.04z" fill="#1D1D1B" p-id="2800"></path><path d="M206.56 505.28s-36.96-108-11.04-159.04 28.48-56 28.48-56 44.96-103.04 139.04-134.08S592 98.24 705.6 168.32s114.08 302.08 112.96 315.04-4 14.08-4 14.08a316.8 316.8 0 0 0-51.04-171.04c-55.04-84-120.96-140.96-247.04-139.04S281.6 288 273.6 308.32s-15.04 34.08-15.04 34.08-13.92-20.96-16.96-20.96-11.04 4-8.96 10.08 16.96 22.08 16.96 26.08a75.36 75.36 0 0 1-4 15.04s-24-21.92-28-19.04-4 16-4 16 23.04 24 22.08 27.04a272 272 0 0 0-17.92 64.96 129.28 129.28 0 0 1-11.2 43.68z" fill="#7B5207" p-id="2801"></path><path d="M212.64 552.32s12.96 36.96 20 54.08a112 112 0 0 1 8 31.04 61.6 61.6 0 0 1-49.92-36.96c-13.12-34.24 17.28-44.16 21.92-48.16zM818.56 563.36s-4.96 20-11.04 42.08a116.64 116.64 0 0 1-12 31.04s46.08-3.04 52-29.92a36 36 0 0 0-28.96-43.2zM530.56 218.24c82.08 0 176.96 44.96 227.04 163.04s39.04 236.96-32.96 303.04-136.96 106.08-259.04 87.04-171.04-87.04-208-171.04S240 220.32 530.56 218.24z" fill="#FCD396" p-id="2802"></path><path d="M355.68 768c8.64-6.4 60.96 47.04 179.04 35.04s135.04-43.04 140-43.04 87.04 60.96 98.08 86.08 8.96 42.08 4 43.04a60.8 60.8 0 0 1-13.92 0s-51.04-83.04-60.96-84-12.96 2.08-11.04 7.04 52.96 80 50.08 80.96-12 8.96-17.92 4.96S676.64 832 672 832s-16 3.04-15.04 6.08 46.08 63.04 42.08 64.96a106.24 106.24 0 0 1-23.04 2.08s-40-59.04-45.92-59.04-9.92 10.08-9.92 10.08 35.04 52 31.04 52a334.08 334.08 0 0 0-83.04-9.92c-40 2.08-71.04 18.08-105.92 14.08S384 880 349.6 878.24s-67.04-1.92-68-5.92 10.08-56.32 74.08-104.32z" fill="#FAB900" p-id="2803"></path><path d="M339.68 349.28c-7.36 0 92.96-20 98.08-13.92s8.96 14.08 0.96 14.08-84.16 18.56-91.04 16.8-7.04-16.96-8-16.96zM637.6 339.36c4 0 88 12 88.96 19.04s7.04 8.96-3.04 10.08a736 736 0 0 1-85.92-13.92c-7.04-2.56 0-15.2 0-15.2zM378.56 379.36c55.04-13.12 132-7.04 128.96 91.04s-117.92 114.08-172.96 75.04-56.96-142.08 44-166.08z" fill="#1D1D1B" p-id="2804"></path><path d="M382.24 393.12c46.56-11.04 112-5.92 109.28 77.12s-100 96-146.56 64-48.32-120.8 37.28-141.12z" fill="#FFFFFF" p-id="2805"></path><path d="M614.56 382.24c48-25.28 127.04 2.08 130.08 91.04s-96.96 108-147.04 67.04-60-116.96 16.96-158.08z" fill="#1D1D1B" p-id="2806"></path><path d="M620.96 396.96c39.36-20.96 105.12 1.6 107.52 75.36s-80 89.44-121.6 55.36-49.6-96.8 14.08-130.72z" fill="#FFFFFF" p-id="2807"></path><path d="M392.64 450.24c14.56-11.36 40-7.04 40.96 12a27.2 27.2 0 0 1-37.92 28.96c-25.12-8.96-11.68-33.92-3.04-40.96zM641.6 450.24c14.56-11.36 40-7.04 40.96 12a27.2 27.2 0 0 1-37.92 28.96c-24.96-8.96-12-33.92-3.04-40.96zM508.64 582.24c4.32 0.8 62.08 35.04 70.08 30.08s2.08-28-8-36-8.96-3.04-9.92-8a6.24 6.24 0 0 1 7.04-8 44 44 0 0 1 34.08 36.96c4.96 30.08-12.96 39.04-36.96 32.96a217.44 217.44 0 0 1-65.92-36.96c-3.04-4 4.64-12 9.6-11.04zM416 660.32c7.04-0.96 34.08 34.08 103.04 31.04a293.6 293.6 0 0 0 80-12 15.04 15.04 0 0 1 12 14.08c-0.96 3.04-45.92 22.08-113.92 16-71.36-6.24-91.04-32.96-92.96-36.96s4.48-11.2 11.84-12.16z" fill="#1D1D1B" p-id="2808"></path></svg>
      <svg t="1610639708230" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2073" width="80" height="80"><path d="M298 771.3h89.7v44.8H298zM477.3 771.3H567v44.8h-89.7z" fill="#206BAB" p-id="2074"></path><path d="M656.7 771.3h89.7v44.8h-89.7z" fill="#206BAB" p-id="2075"></path><path d="M492.3 68.9L93.5 693.6c-21.4 33.5 2.8 77.3 42.5 77.1h774.1c37.4-0.2 63.9-46.5 43.6-77.9L552 68.9c-24-35.8-35.9-35.8-59.7 0z m0 0" fill="#EEAC38" p-id="2076"></path><path d="M136 770.7c-39.7 0.2-63.9-43.6-42.5-77.1L492.3 68.9s8.9-17.3 25.8-14.9l4 716.8H136z m0 0" fill="#F0BB5D" p-id="2077"></path><path d="M581.9 128.6H462.4s34.5-74.1 57.9-74.7c36.2-0.9 61.6 74.7 61.6 74.7z m0 0" fill="#74A2CA" p-id="2078"></path><path d="M402.6 771.3H283V547.1c0-33 26.8-59.8 59.8-59.8s59.8 26.8 59.8 59.8v224.2z m0 0" fill="#206BAB" p-id="2079"></path><path d="M283 711.5h119.6v59.8H283z" fill="#FFFFFF" p-id="2080"></path><path d="M761.3 771.3H641.7V547.1c0-33 26.8-59.8 59.8-59.8s59.8 26.8 59.8 59.8v224.2z m0 0" fill="#206BAB" p-id="2081"></path><path d="M641.7 711.5h119.6v59.8H641.7z" fill="#FFFFFF" p-id="2082"></path><path d="M178.4 771.3h-47.7c-31.5 0-51.1-29.7-42-59.8 11.7-38.7 89.7-151 89.7-151v210.8z m0 0M865.9 771.3h47.7c31.5 0 53.4-32.4 44.2-62.5-11.7-38.7-91.9-152.4-91.9-152.4v214.9z m0 0" fill="#74A2CA" p-id="2083"></path><path d="M626.8 317.6c0-57.8-46.8-104.6-104.6-104.6s-104.6 46.8-104.6 104.6l104.6 59.8 104.6-59.8z m0 0" fill="#FFFFFF" p-id="2084"></path><path d="M298 831h29.9v44.8h29.9V831h29.9v-29.9H298V831z m0 0M746.3 801.2h-89.7V831h29.9v44.8h29.9V831h29.9v-29.8z m0 0M567 801.2h-89.7V831h29.9v44.8h29.9V831H567v-29.8z m0 0M73.8 801.2h29.9v209.2H73.8zM133.6 875.9h29.9v104.6h-29.9zM178.4 801.2h29.9V846h-29.9zM940.6 801.2h29.9v209.2h-29.9zM880.8 875.9h29.9v104.6h-29.9zM836 801.2h29.9V846H836zM487.9 303.6l-21.1-21.1 29.9-29.9 21.1 21.1-29.9 29.9z m0 0M547.7 303.6l-21.1-21.1 29.9-29.9 21.1 21.1-29.9 29.9z m0 0M327.9 905.8h29.9v104.6h-29.9zM507.2 905.8h29.9v104.6h-29.9zM686.6 905.8h29.9v104.6h-29.9z" fill="#1C1C1A" p-id="2085"></path><path d="M447.4 517.2h29.9v29.9h-29.9zM447.4 577h29.9v29.9h-29.9zM447.4 636.8h29.9v29.9h-29.9zM567 577h29.9v29.9H567zM567 636.8h29.9v29.9H567z" fill="#FFFFFF" p-id="2086"></path><path d="M567 517.2h29.9v29.9H567z" fill="#FFFFFF" p-id="2087"></path><path d="M961 698.2L568.2 64.6c-9.9-16-27.1-25.6-46-25.6s-36.1 9.6-46 25.6L83.3 698.2c-10.5 16.9-11 37.4-1.3 54.9 9.7 17.4 27.4 27.8 47.3 27.8H915c19.9 0 37.6-10.4 47.3-27.8 9.7-17.4 9.2-37.9-1.3-54.9zM701.5 502.3c24.7 0 44.8 20.1 44.8 44.8v149.5h-89.7V547.1c0.1-24.7 20.2-44.8 44.9-44.8z m-44.8 224.1h89.7V751h-89.7v-24.6z m59.7-252.5v-31.4h-29.9v31.4c-34.1 6.9-59.8 37.1-59.8 73.2V751H537V386l104.6-59.8v-8.7c0-65.9-53.6-119.6-119.6-119.6s-119.6 53.6-119.6 119.6v8.7L507 386v365h-89.7V547.1c0-36.1-25.7-66.3-59.8-73.2v-31.4h-29.9v31.4c-34.1 6.9-59.8 37.1-59.8 73.2V751h-74.7V577.4l269-433.8H582l269 433.8V751h-74.7V547.1c-0.1-36.1-25.8-66.3-59.9-73.2zM522.2 360.2l-89.3-51c4.3-45.5 42.7-81.2 89.3-81.2 46.6 0 85 35.7 89.3 81.2l-89.3 51zM342.8 502.3c24.7 0 44.8 20.1 44.8 44.8v149.5H298V547.1c0-24.7 20.1-44.8 44.8-44.8zM298 726.4h89.7V751H298v-24.6zM501.5 80.3c4.5-7.3 12-11.5 20.6-11.5s16.1 4.2 20.6 11.5l20.7 33.4h-82.6l20.7-33.4zM108.1 738.6c-4.3-7.8-4.1-17 0.6-24.6l54.8-88.4V751h-34.2c-8.9 0-16.9-4.6-21.2-12.4z m828.1 0c-4.3 7.8-12.3 12.5-21.2 12.5h-34.2V625.6l54.8 88.4c4.7 7.6 5 16.8 0.6 24.6z m0 0" fill="#1C1C1A" p-id="2088"></path></svg>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.rcode.top/2021/06/28/java/%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://z3.ax1x.com/2021/05/30/2VQ8M9.jpg">
      <meta itemprop="name" content="河神">
      <meta itemprop="description" content="你可以跑,但你不能躲">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rick-Code">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/28/java/%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99/" class="post-title-link" itemprop="url">服务容错设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-06-28 00:00:00 / 修改时间：13:16:57" itemprop="dateCreated datePublished" datetime="2021-06-28T00:00:00+08:00">2021-06-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="容错策略"><a href="#容错策略" class="headerlink" title="容错策略"></a>容错策略</h2><table>
<thead>
<tr>
<th>容错策略</th>
<th>一般实现</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>故障转移</td>
<td>重试模式</td>
<td></td>
</tr>
<tr>
<td>快速失败</td>
<td>断路器模式</td>
<td></td>
</tr>
<tr>
<td>安全失败</td>
<td>断路器模式</td>
<td></td>
</tr>
<tr>
<td>沉默失败</td>
<td>舱壁隔离模式</td>
<td></td>
</tr>
<tr>
<td>故障恢复</td>
<td>重试模式</td>
<td></td>
</tr>
<tr>
<td>并行调用</td>
<td></td>
<td></td>
</tr>
<tr>
<td>广播调用</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="服务容错设计模式"><a href="#服务容错设计模式" class="headerlink" title="服务容错设计模式"></a>服务容错设计模式</h1><h2 id="断路器模式"><a href="#断路器模式" class="headerlink" title="断路器模式"></a>断路器模式</h2><h3 id="断路器是什么"><a href="#断路器是什么" class="headerlink" title="断路器是什么"></a>断路器是什么</h3><ul>
<li>通过代理（断路器对象）来一对一（一个远程服务对应一个断路器对象）地接管服务调用者的远程请求。</li>
<li>断路器会持续监控并统计服务返回的成功、失败、超时、拒绝等各种结果，当出现故障（失败、超时、拒绝）的次数达到断路器的阈值时，它的状态就自动变为“OPEN”。之后这个断路器代理的远程访问都将直接返回调用失败，而不会发出真正的远程服务请求。</li>
<li>通过断路器对远程服务进行熔断，就可以避免因为持续的失败或拒绝而消耗资源，因为持续的超时而堆积请求，最终可以避免雪崩效应的出现。由此可见，<strong>断路器本质上是快速失败策略的一种实现方式。</strong></li>
</ul>
<p><strong><img src="https://raw.githubusercontent.com/MortyCode/image/master/blog/image.png" alt="image.png"></strong><br>**</p>
<ul>
<li><strong>断路器就是一种有限状态机，断路器模式就是根据自身的状态变化，自动调整代理请求策略的过程</strong>。断路器一般可以设置为 CLOSED、OPEN 和 HALF OPEN 三种状态。</li>
</ul>
<ul>
<li>CLOSED：表示断路器关闭，此时的远程请求会真正发送给服务提供者。断路器刚刚建立时默认处于这种状态，此后将持续监视远程请求的数量和执行结果，决定是否要进入 OPEN 状态。</li>
</ul>
<ul>
<li>OPEN：表示断路器开启，此时不会进行远程请求，直接给服务调用者返回调用失败的信息，以实现快速失败策略</li>
</ul>
<ul>
<li>HALF OPEN：是一种中间状态。断路器必须带有自动的故障恢复能力，当进入 OPEN 状态一段时间以后，将“自动”（一般是由下一次请求而不是计时器触发的，所以这里的自动是带引号的）切换到 HALF OPEN 状态。在中间状态下，会放行一次远程调用，然后根据这次调用的结果成功与否，转换为 CLOSED 或者 OPEN 状态，来实现断路器的弹性恢复。<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="断路器的状态转换"><a href="#断路器的状态转换" class="headerlink" title="断路器的状态转换"></a>断路器的状态转换</h4></li>
</ul>
<p><img src="https://raw.githubusercontent.com/MortyCode/image/master/blog/rongcuostatsu.png" alt="image.png"></p>
<h3 id="一般的状态转换条件"><a href="#一般的状态转换条件" class="headerlink" title="一般的状态转换条件"></a>一般的状态转换条件</h3><ul>
<li><p>一般来说，从CLOSE进入OPEN,不会一次失败就直接进入，这样做的效果非常差，虽然避免了故障扩散和请求堆积，却使得在外部看来系统表现的极其不稳定。</p>
</li>
<li><p>可以增加一些进入条件，比如当一次调用失败后，如果还同时满足下面两个条件，断路器的状态就变为 OPEN：</p>
<ul>
<li>一段时间（比如 10 秒以内）内，请求数量达到一定阈值（比如 20 个请求）。这个条件的意思是，如果请求本身就很少，那就用不着断路器介入</li>
<li>一段时间（比如 10 秒以内）内，请求的故障率（发生失败、超时、拒绝的统计比例）到达一定阈值（比如 50%）。这个条件的意思是，如果请求本身都能正确返回，也用不着断路器介入。<h3 id="服务熔断和服务降级"><a href="#服务熔断和服务降级" class="headerlink" title="服务熔断和服务降级"></a>服务熔断和服务降级</h3></li>
</ul>
</li>
<li><p>断路器做的事情是自动进行服务熔断，属于一种快速失败的容错策略的实现方法</p>
</li>
</ul>
<ul>
<li></li>
<li><p>服务降级是从整个系统的负荷情况出发和考虑的，对某些负荷会比较高的情况，为了预防某些功能（业务场景）出现负荷过载或者响应慢的情况，在其内部暂时舍弃对一些非核心的接口和数据的请求，而直接返回一个提前准备好的fallback（退路）错误处理信息。这样，虽然提供的是一个有损的服务，但却保证了整个系统的稳定性和可用性。</p>
</li>
</ul>
<ul>
<li>相同点<ul>
<li>目标一致 都是从可用性和可靠性出发，为了防止系统崩溃；</li>
<li>用户体验类似 最终都让用户体验到的是某些功能暂时不可用；</li>
</ul>
</li>
<li>不同点<ul>
<li>触发原因不同 服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑； </li>
</ul>
</li>
</ul>
<h2 id="舱壁隔离模式-服务隔离"><a href="#舱壁隔离模式-服务隔离" class="headerlink" title="舱壁隔离模式- 服务隔离"></a>舱壁隔离模式- 服务隔离</h2><blockquote>
<p>舱壁隔离模式，是常用的实现服务隔离的设计模式。“舱壁”这个词来自造船业，它原本的意思是设计舰船时，要在每个区域设计独立的水密舱室，一旦某个舱室进水，也只会影响到这个舱室中的货物，而不至于让整艘舰艇沉没。</p>
</blockquote>
<ul>
<li>服务隔离，就是避免某一个远程服务的局部失败影响到全局，而设置的一种止损方案。这种思想，对应的就是容错策略中的失败静默策略。那为什么会有一个服务失败会影响全局的事情发生呢？<ul>
<li>调用外部服务的故障分为了失败、拒绝和超时三大类。“超时”引起的故障，尤其容易给调用者带来全局性的风险。这是因为，目前主流的网络访问大多是基于 TPR 并发模型（Thread per Request）来实现的，只要请求一直不结束（无论是以成功结束还是以失败结束），就要一直占用着某个线程不能释放。而线程是典型的整个系统的全局性资源，尤其是在 Java 这类将线程映射为操作系统内核线程来实现的语言环境中。</li>
<li>简单来说，因为超时，导致多个线程等待，最终造成服务不可用，造成雪崩效应。</li>
</ul>
</li>
</ul>
<h4 id="微观层面实现"><a href="#微观层面实现" class="headerlink" title="微观层面实现"></a>微观层面实现</h4><ul>
<li><p>针对超时的处理，如果某个微服务超时，然后多个线程一直在等待，</p>
<ul>
<li>具体来说就是，本地请求某个服务的资源进行限制，保证一个服务的超时，不影响整体服务</li>
<li>解决方式：<ul>
<li>为每个服务单独设立线程池，这些线程池默认不预置活动线程，只用来控制单个服务的最大连接数。</li>
<li>信号量机制<h4 id="服务层面"><a href="#服务层面" class="headerlink" title="服务层面"></a>服务层面</h4></li>
</ul>
</li>
</ul>
</li>
<li><p>服务调用的角度应用舱壁隔离设计模式，实际上舱壁隔离模式还可以在更高层、更宏观的场景中使用，不按调用线程，而是按功能、按子系统、按用户类型等条件来隔离资源都是可以的。比如，根据用户等级、用户是否是 VIP、用户来访的地域等各种因素，将请求分流到独立的服务实例去，这样即使某一个实例完全崩溃了，也只是影响到其中某一部分的用户，把波及范围尽可能控制住。</p>
</li>
</ul>
<ul>
<li>一般来说，我们会选择将服务层面的隔离实现在服务调用端或者边车代理上，将系统层面的隔离实现在 DNS 或者网关处。</li>
</ul>
<h2 id="重试模式"><a href="#重试模式" class="headerlink" title="重试模式"></a>重试模式</h2><h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><p>重试模式适合解决系统中的瞬时故障，简单地说就是有可能自己恢复（Resilient，称为自愈，也叫做回弹性）的临时性失灵，比如网络抖动、服务的临时过载（比如返回了 503 Bad Gateway 错误）这些都属于瞬时故障。</p>
<h3 id="是否可以重试"><a href="#是否可以重试" class="headerlink" title="是否可以重试"></a>是否可以重试</h3><ol>
<li>仅在主路逻辑的关键服务上进行同步的重试。也就是说，如果不是关键的服务，一般不要把重试作为首选的容错方案，尤其不应该进行同步重试。</li>
<li>仅对由瞬时故障导致的失败进行重试。例如根据错误进行判断，例如如果是权限问题，就不需要，</li>
<li>仅对具备幂等性的服务进行重试。</li>
<li>重试必须有明确的终止条件<ol>
<li>超时终止，超时机制并不限于重试策略，所有涉及远程调用的服务都应该有超时机制来避免无限期的等待。</li>
<li>次数终止，重试必须要有一定限度，不能无限制地做下去，通常是重试 2~5 次。因为重试不仅会给调用者带来负担，对服务提供者来说也同样是负担，所以我们要避免把重试次数设得太大</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.rcode.top/2021/05/20/es/es4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://z3.ax1x.com/2021/05/30/2VQ8M9.jpg">
      <meta itemprop="name" content="河神">
      <meta itemprop="description" content="你可以跑,但你不能躲">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rick-Code">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/20/es/es4/" class="post-title-link" itemprop="url">ES聚合</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-20 00:00:00" itemprop="dateCreated datePublished" datetime="2021-05-20T00:00:00+08:00">2021-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-31 15:30:03" itemprop="dateModified" datetime="2021-05-31T15:30:03+08:00">2021-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/es/" itemprop="url" rel="index"><span itemprop="name">es</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="集合分类"><a href="#集合分类" class="headerlink" title="集合分类"></a>集合分类</h1><table>
<thead>
<tr>
<th>聚合类型</th>
<th></th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Metric</td>
<td>度量</td>
<td>一些数学运算，可以对文档进行统计分析</td>
</tr>
<tr>
<td>Bucket</td>
<td>分组桶</td>
<td>一些列满足特点条件的文档聚合</td>
</tr>
<tr>
<td>Pipeline</td>
<td>管道</td>
<td>对其他聚合结果，进行二次聚合</td>
</tr>
<tr>
<td>Matrix</td>
<td>矩阵</td>
<td>支持对多个文档的操作并且提供一个结果矩阵</td>
</tr>
</tbody></table>
<h1 id="度量聚合"><a href="#度量聚合" class="headerlink" title="度量聚合"></a>度量聚合</h1><ul>
<li><p>度量聚合从文档中提c取出来值并进行计算。这些值通常从文档中的字段（使用数据字段）中提取出来，但也可以使用脚本进行计算。</p>
</li>
<li><p>数字型度量聚合是一种特殊类型的度量聚合，输出数字类型的值。</p>
</li>
<li><p>聚合输出一个数字指标（例如平均值聚合）称为单值数字型度量聚合，产生多个指标值（例如统计聚合）称为多值数字型度量聚合。</p>
</li>
<li><p>当这些聚合直接作为一些分组聚合的子聚合时，单值和多值数字型度量聚合的内容就会发挥巨大的作用，例如分组聚合可以对度量聚合后的返回的值进行排序。</p>
<h2 id="求和-Sum"><a href="#求和-Sum" class="headerlink" title="求和 Sum"></a>求和 Sum</h2></li>
<li><p>对聚合文档提取的数字进行求和</p>
</li>
<li><p>包括 <strong>简单字段求和</strong> 和 <strong>通过脚本提取</strong></p>
</li>
<li><p>可以使用missing参数设置不存在的值的默认统计值</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;price_sum&quot;: &#123;</span><br><span class="line">      &quot;sum&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;price&quot;,</span><br><span class="line">        &quot;missing&quot;: 10</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;price_sum_scr_field&quot;: &#123;</span><br><span class="line">      &quot;sum&quot;: &#123;</span><br><span class="line">       &quot;script&quot;: &quot;doc.price.value&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;price_sum_sct&quot;: &#123;</span><br><span class="line">      &quot;sum&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;price&quot;,</span><br><span class="line">        &quot;script&quot;: &#123;</span><br><span class="line">          &quot;lang&quot;:   &quot;expression&quot;,</span><br><span class="line">          &quot;source&quot;: &quot;_value * sp&quot;, </span><br><span class="line">          &quot;params&quot;: &#123;</span><br><span class="line">             &quot;sp&quot;: 0.5</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>上面包含三种查询，<br>第一个 通过field获取求和字段，并且设置不存在的值为统计时为10<br>第二个 通过脚本获取统计参数<br>第三个 通过field获取求和字段，通过脚本将获取的值乘 0.5 之后进行统计</p>
</li>
</ul>
<h2 id="其他类似度量聚合"><a href="#其他类似度量聚合" class="headerlink" title="其他类似度量聚合"></a>其他类似度量聚合</h2><ul>
<li>其他的一些统计的求和用法差不多<table>
<thead>
<tr>
<th>维度</th>
<th>关键字</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>计数</td>
<td>value_count</td>
<td></td>
</tr>
<tr>
<td>最大值</td>
<td>max</td>
<td></td>
</tr>
<tr>
<td>最小值</td>
<td>min</td>
<td></td>
</tr>
<tr>
<td>平均数</td>
<td>avg</td>
<td></td>
</tr>
<tr>
<td>统计聚合</td>
<td>stats</td>
<td>一次将最大值，最小值，和，计数，平均数 返回</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="基数聚合"><a href="#基数聚合" class="headerlink" title="基数聚合"></a>基数聚合</h2><ul>
<li><p>计算某个字段有多少个不同的值，类似于 count(DISTINCT  field )</p>
</li>
<li><p>基于  <a target="_blank" rel="noopener" href="http://static.googleusercontent.com/media/research.google.com/fr//pubs/archive/40671.pdf">HyperLogLog++</a> 实现的，所以其统计值并不一定是准确的值</p>
</li>
<li><p>支持脚本，不过使用脚本的时候，性能损失很大</p>
</li>
<li><p>通过参数 precision_threshold  可以设置准确性，使用内存来换取准确性。</p>
<ul>
<li>在大于这个值的时候结果比较模糊</li>
<li>小于这个值的时候，接近于准确</li>
<li>最大参数为40000，默认 3000<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;aggs&quot;: &#123;</span><br><span class="line">  &quot;price_count&quot;: &#123;</span><br><span class="line">    &quot;cardinality&quot;: &#123;</span><br><span class="line">      &quot;field&quot;: &quot;price&quot;,</span><br><span class="line">      &quot;precision_threshold&quot;: 100,</span><br><span class="line">      &quot;missing&quot;: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="百分位数统计"><a href="#百分位数统计" class="headerlink" title="百分位数统计"></a>百分位数统计</h2><h3 id="百分位数是什么"><a href="#百分位数是什么" class="headerlink" title="百分位数是什么"></a>百分位数是什么</h3>如果将一组数据从小到大排序，并计算相应的累计百分位，则某一百分位所对应数据的值就称为这一百分位的百分位数。可表示为：一组n个观测值按数值大小排列。如，处于p%位置的值称第p百分位数。<br>即如果有某个百分比的数据低于一个值，这个值便叫某个百分比的百分位数。<br>例如：你是班上 20个学生里身高第四的学生，80% 的学生比你矮，你身高是第 80个百分位数（百分等级是 80%）。如果你的身高是 1.85m，”1.85m” 是班上身高的 80% 百分数。<h3 id="如何计算"><a href="#如何计算" class="headerlink" title="如何计算"></a>如何计算</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">原数据：</span><br><span class="line"><span class="number">10</span> <span class="number">12</span> <span class="number">16</span> <span class="number">20</span> <span class="number">25</span> <span class="number">30</span> <span class="number">40</span> <span class="number">45</span> </span><br><span class="line"></span><br><span class="line">我们需要计算 50% 的 百分位数</span><br><span class="line"></span><br><span class="line">公式为 Location=（n+1）* percentile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">L = (8+1)* 50 /100 = 4.5 </span><br><span class="line"></span><br><span class="line">此时计算出的值为4.5，不是整数，那么还需要计算 4位置 和 5位置 直接的百分位数</span><br><span class="line">计算公式为：</span><br><span class="line"></span><br><span class="line">Location = Location(L/1)+ percentile * (L/1+1 - L/1) </span><br><span class="line"></span><br><span class="line">L 20 + 0.5 (35-20) = 22.5 </span><br><span class="line"></span><br><span class="line">此时说明，50%的数字的值都在 22.5 之下，比22.5小</span><br><span class="line"></span><br><span class="line">    &quot;price_count&quot; : &#123;</span><br><span class="line">      &quot;values&quot; : &#123;</span><br><span class="line">        &quot;1.0&quot; : 10.0,</span><br><span class="line">        &quot;5.0&quot; : 10.0,</span><br><span class="line">        &quot;25.0&quot; : 14.0,</span><br><span class="line">        &quot;50.0&quot; : 22.5,</span><br><span class="line">        &quot;75.0&quot; : 35.0,</span><br><span class="line">        &quot;95.0&quot; : 45.0,</span><br><span class="line">        &quot;99.0&quot; : 45.0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;price_count&quot;: &#123;</span><br><span class="line">      &quot;percentiles&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;price&quot;,</span><br><span class="line">        &quot;percents&quot;: [</span><br><span class="line">          1,</span><br><span class="line">          5,</span><br><span class="line">          25,</span><br><span class="line">          50,</span><br><span class="line">          75,</span><br><span class="line">          95,</span><br><span class="line">          <span class="number">99</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">resp:</span><br><span class="line">  &quot;aggregations&quot; : &#123;</span><br><span class="line">    &quot;price_count&quot; : &#123;</span><br><span class="line">      &quot;values&quot; : &#123;</span><br><span class="line">        &quot;1.0&quot; : 10.0,</span><br><span class="line">        &quot;5.0&quot; : 10.0,</span><br><span class="line">        &quot;25.0&quot; : 14.0,</span><br><span class="line">        &quot;50.0&quot; : 22.5,</span><br><span class="line">        &quot;75.0&quot; : 35.0,</span><br><span class="line">        &quot;95.0&quot; : 45.0,</span><br><span class="line">        &quot;99.0&quot; : 45.0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="百分数-数值聚合"><a href="#百分数-数值聚合" class="headerlink" title="百分数 数值聚合"></a>百分数 数值聚合</h2></li>
</ul>
</li>
<li><p>上面的百分位统计是统计<strong>每个百分位的值是多少</strong>，而这个统计是统计 <strong>当前值在文档的百分位中是多少</strong></p>
</li>
<li><p>是百分位统计的逆计算</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;price_count&quot;: &#123;</span><br><span class="line">      &quot;percentile_ranks&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;price&quot;,</span><br><span class="line">        &quot;values&quot;: [14,22.5]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">resp:</span><br><span class="line">    &quot;price_count&quot; : &#123;</span><br><span class="line">      &quot;values&quot; : &#123;</span><br><span class="line">        &quot;14.0&quot; : 25.0,</span><br><span class="line">        &quot;22.5&quot; : 50.0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="脚本统计"><a href="#脚本统计" class="headerlink" title="脚本统计"></a>脚本统计</h2></li>
<li><p>当es提供的统计不能满足我们的要求的时候，我们可以选择自己通过脚本实现统计</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;aggs&quot;: &#123;</span><br><span class="line">  &quot;price_count&quot;: &#123;</span><br><span class="line">    &quot;scripted_metric&quot;: &#123;</span><br><span class="line">       &quot;init_script&quot;: &quot;state.transactions = []&quot;,</span><br><span class="line">       &quot;map_script&quot;: &quot;state.transactions.add(doc.price.value)&quot;,</span><br><span class="line">       &quot;combine_script&quot;: &quot;double profit = 0; for (t in state.transactions) &#123; profit += t &#125; return profit&quot;,</span><br><span class="line">       &quot;reduce_script&quot;: &quot;double profit = 0; for (a in states) &#123; profit += a &#125; return profit&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>脚本统计分为4个阶段</p>
</li>
</ul>
<ol>
<li>初始化脚本 (init_script) 在任何文档的收集之前执行。允许聚合设置任何初始化状态。</li>
<li>映射脚本（map_script）,每个被采集的文档都会执行一次脚本。这是唯一必须的脚本。如果没有指定联合脚本，结果状态需要存储在一个名为_agg的对象中</li>
<li>联合脚本（combine_script）,每个分片会在文档采集结束的时候执行一次脚本。允许聚合从每个分片中统一状态。如果没有提供联合脚本，联合阶段就会返回聚合变量。</li>
<li>归纳脚本（reduce_script）。在所有分片返回结果之后，请求节点执行一次脚本。这个脚本用于访问_aggs变量，_aggs变量是每个分片执行联合脚本之后的结果数组。如果没有提供归纳脚本，归纳阶段会返回_aggs变量。</li>
</ol>
<p><img src="https://heshen-1257140474.cos.ap-nanjing.myqcloud.com/aggs1.png" alt="image.png"></p>
<h2 id="地理边界聚合"><a href="#地理边界聚合" class="headerlink" title="地理边界聚合"></a>地理边界聚合</h2><ul>
<li>为一个geo类型的字段计算包含所有点的边界框。</li>
<li>返回左上 和 右下的点<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;viewport&quot; : &#123;</span><br><span class="line">            &quot;geo_bounds&quot; : &#123;</span><br><span class="line">                &quot;field&quot; : &quot;location&quot;, </span><br><span class="line">                &quot;wrap_longitude&quot; : true </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">wrap_longitude: 用于指定是否应允许边界框与国际日期线重叠</span><br><span class="line"></span><br><span class="line">resp:</span><br><span class="line">  &quot;aggregations&quot; : &#123;</span><br><span class="line">    &quot;viewport&quot; : &#123;</span><br><span class="line">      &quot;bounds&quot; : &#123;</span><br><span class="line">        &quot;top_left&quot; : &#123;</span><br><span class="line">          &quot;lat&quot; : 35.234553990885615,</span><br><span class="line">          &quot;lon&quot; : 107.80624595470726</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;bottom_right&quot; : &#123;</span><br><span class="line">          &quot;lat&quot; : 33.65711996331811,</span><br><span class="line">          &quot;lon&quot; : 110.34507296048105</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="地理中心聚合"><a href="#地理中心聚合" class="headerlink" title="地理中心聚合"></a>地理中心聚合</h2><ul>
<li><p>为一个geo类型的字段计算包含所有点的中心点</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  &quot;aggs&quot; : &#123;</span><br><span class="line">      &quot;centroid&quot; : &#123;</span><br><span class="line">          &quot;geo_centroid&quot; : &#123;</span><br><span class="line">              &quot;field&quot; : &quot;location&quot; </span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;aggregations&quot; : &#123;</span><br><span class="line">  &quot;centroid&quot; : &#123;</span><br><span class="line">    &quot;location&quot; : &#123;</span><br><span class="line">      &quot;lat&quot; : 34.5458007780835,</span><br><span class="line">      &quot;lon&quot; : 109.24376476183534</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;count&quot; : 5</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分组聚合-桶聚合"><a href="#分组聚合-桶聚合" class="headerlink" title="分组聚合 桶聚合"></a>分组聚合 桶聚合</h1></li>
<li><p>分组聚合不像度量聚合那样直接通过字段聚合，而是根据字段的值，创建分组桶。</p>
</li>
<li><p>每个分组桶都和一个标准（取决于聚合类型）相关联，该标准确定当前上下文中的文档是否“落入”其中。换句话说，存储桶有效地定义了文档集。除了存储桶本身之外，<code>bucket</code>聚合还计算并返回“落入”每个存储桶的文档数量。</p>
</li>
<li><p>分组聚合还可以实现子聚合，这些子聚合可以针对父聚合的分组桶进行聚合。</p>
</li>
<li><p>可以定义单分组桶，多分组桶，动态创建分组桶，等</p>
</li>
<li><p>单个请求最多返回的分组桶受 search.max_buckets 参数影响，默认-1（不启用），但是这个时候最多返回10,000个分组</p>
<h2 id="Terms-Aggregation"><a href="#Terms-Aggregation" class="headerlink" title="Terms Aggregation"></a>Terms Aggregation</h2></li>
<li><p>按照某个字段中的值来分类，基于字段的值动态创建桶</p>
</li>
<li><p>字段需要打开fiel data 才能使用terms</p>
<ul>
<li>keyword 需要支持doc_value</li>
<li></li>
</ul>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;type_terms&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;type.keyword&quot;,</span><br><span class="line">        &quot;size&quot;: 10</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">resp:</span><br><span class="line"></span><br><span class="line">  &quot;aggregations&quot; : &#123;</span><br><span class="line">    &quot;type_terms&quot; : &#123;</span><br><span class="line">      &quot;doc_count_error_upper_bound&quot; : 0,</span><br><span class="line">      &quot;sum_other_doc_count&quot; : 0,</span><br><span class="line">      &quot;buckets&quot; : [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;key&quot;</span> : <span class="string">&quot;t1&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;doc_count&quot;</span> : <span class="number">3</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;key&quot;</span> : <span class="string">&quot;t4&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;doc_count&quot;</span> : <span class="number">3</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;key&quot;</span> : <span class="string">&quot;t2&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;doc_count&quot;</span> : <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;key&quot;</span> : <span class="string">&quot;t3&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;doc_count&quot;</span> : <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>doc_count_error_upper_bound: 每个索引文档的计数错误上限。</p>
</li>
<li><p>sum_other_doc_count: 没有被放在桶中的文档计数总和</p>
<h3 id="Size"><a href="#Size" class="headerlink" title="Size"></a>Size</h3></li>
<li><p>返回桶的数量</p>
</li>
<li><p>如果分组多于size，则返回的可能不是所有的数据，而且返回的可能不是前几个桶，有可能有偏差，数量也有可能有偏差</p>
</li>
<li><p>如果需要对聚合的结果进行分页，则应该使用composite 聚合，而不是把size设置为一个很大的值</p>
</li>
</ul>
<h3 id="文件数数一个大概值"><a href="#文件数数一个大概值" class="headerlink" title="文件数数一个大概值"></a>文件数数一个大概值</h3><ul>
<li>因为在聚合中，每个分片都提供了自己的视图，将他们组合在一起形成真正的视图</li>
</ul>
<p><img src="https://heshen-1257140474.cos.ap-nanjing.myqcloud.com/aggs2.png" alt="image.png"></p>
<h3 id="在返回值的参数就是描述这个"><a href="#在返回值的参数就是描述这个" class="headerlink" title="在返回值的参数就是描述这个"></a>在返回值的参数就是描述这个</h3><ul>
<li><p>doc_count_error_upper_bound </p>
<ul>
<li>表示没有在本次返回，但是可能存在的潜在聚合结果。被遗漏的可能的最大值。</li>
<li>主聚合的值取的是每个分片取的数据的最小值相加</li>
<li>各个桶取的是 通过将所有未返回该词条的分片返回的最后一个词的文档计数相加得出的，表示文档计数中最坏的情况。表示最坏少多少个元素</li>
</ul>
</li>
<li><p>sum_other_doc_count：表示的是蓝框当中的部分，本次返回之外的聚合文档数</p>
</li>
<li><p>从代码上看，我们可以看到如果我们这个值应该取的是每个桶的最小的一个值累加</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">从源码看的话：</span><br><span class="line"></span><br><span class="line">    private long getDocCountError(A terms) &#123;</span><br><span class="line">        int size = terms.getBuckets().size();</span><br><span class="line">        if (size == 0 || size &lt; terms.getShardSize() || isKeyOrder(terms.getOrder())) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else if (InternalOrder.isCountDesc(terms.getOrder())) &#123;</span><br><span class="line">            if (terms.getDocCountError() &gt; 0) &#123;</span><br><span class="line">                <span class="comment">// If there is an existing docCountError for this agg then</span></span><br><span class="line">                <span class="comment">// use this as the error for this aggregation</span></span><br><span class="line">                return terms.getDocCountError();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                <span class="comment">// otherwise use the doc count of the last term in the</span></span><br><span class="line">                <span class="comment">// aggregation</span></span><br><span class="line">                return terms.getBuckets().stream().mapToLong(AbstractTermsBucket::getDocCount).min().getAsLong();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="shard-size"><a href="#shard-size" class="headerlink" title="shard_size"></a>shard_size</h3></li>
<li><p>shard_size参数就是哪个红框返回分组数据量</p>
</li>
<li><p>默认的分组数为 <code>size``(size * 1.5 + 10)</code></p>
</li>
<li><p>当shard_size值越大的时候，返回的数据越准确，当上图我们把shard_size设置为8的时候，H也可以被统计进去，结果就不一样了。但是这样也会带来计算成本的增加</p>
</li>
<li><p>shard_size不能小于size，因为没有意义，即使设置，es也会重置为size</p>
<h3 id="展示每个桶的错误"><a href="#展示每个桶的错误" class="headerlink" title="展示每个桶的错误"></a>展示每个桶的错误</h3></li>
<li><p>show_term_doc_count_error 设置为true的时候，可以展示每个桶的可能错误值</p>
</li>
<li><p>各个桶取的是 通过将所有未返回该词条的分片返回的最后一个词的文档计数相加得出的，表示文档计数中最坏的情况。表示最坏少多少个元素</p>
</li>
<li><p>代码在  org.elasticsearch.search.aggregations.bucket.terms.AbstractInternalTerms#reduce</p>
<h3 id="Execution-hint"><a href="#Execution-hint" class="headerlink" title="Execution hint"></a>Execution hint</h3></li>
<li><p><code>map</code>, 直接使用该字段的字符串值来做聚合</p>
</li>
<li><p><code>global_ordinals</code>: 默认选项，</p>
<h3 id="global-ordinals"><a href="#global-ordinals" class="headerlink" title="global_ordinals"></a>global_ordinals</h3></li>
</ul>
<p><img src="https://heshen-1257140474.cos.ap-nanjing.myqcloud.com/aggs3.png" alt="image.png"></p>
<ul>
<li><p>Global Ordinals 一个分片级别全局的映射字典，即用一个序号来代表一个唯一字符串，在进行terms统计的时候，直接为每一个序号生成一个桶，在获取文档的时候，就不用把字段值加载到内存中进行计算，只要加载字典的序号就可以，然后遍历映射到桶中，就可以很快的统计出每个桶的文档数</p>
</li>
<li><p>使用Global Ordinals的目的在于减少内存使用，加快聚合统计，这种计算方式主要开销在构建global ordinals和分配bucket上，如果索引包含的原始文档非常多，查询结果包含的文档也很多，那么默认的这种计算方式是内存消耗最小，速度最快的。</p>
</li>
<li><p><strong>问题</strong>：</p>
<ul>
<li> 这种方式是懒加载的，而且是在开始之前进行的，这样导致在字段种类特别大的情况下，即使过滤的文档很少，也会很慢</li>
<li>关系在shard被触发refresh以后就会失效。下次使用的话就需要重新构建，</li>
<li>而且这份数据常驻内存</li>
</ul>
</li>
<li><p><strong>优化方法：</strong></p>
<ul>
<li>增加分片数量，即减少每个分片创建映射的时间</li>
<li>延长refresh_interval的时间，但是数据的实时性就会打折扣</li>
<li>修改execution_hint的值：当把值从 <code>global_ordinals</code>改为<code>map</code>，每次聚合的时候直接把值加载到内存中计算，减去了构建字典的耗时。当查询的结果集很小的情况下，可以使用map的模式不去构建字典。使用map还是global_ordinals的取决于构建字典的开销与加载原始字典的开销。当结果集大到一定程序，map的内存开销的代价可能抵消了构建字典的开销。<h3 id="收集模式"><a href="#收集模式" class="headerlink" title="收集模式"></a>收集模式</h3></li>
</ul>
</li>
<li><p>depth_first 深度优先搜索，直接进行子聚合的计算</p>
</li>
<li><p>breadth_first 广度优先搜索，先计算出当前聚合的结果，针对这个结果在对子聚合进行计算</p>
<ul>
<li>会把上层的桶的文档集合存储起来，以供后续使用，会产生内存开销</li>
<li>该内存开销与匹配文档的数量成线性关系<h3 id="参数Order"><a href="#参数Order" class="headerlink" title="参数Order"></a>参数Order</h3></li>
</ul>
</li>
<li><p>指定了最后返回结果的排序方式，默认是按照doc_count降序排列。一般不建议按照升序排序，因为这样会增加文档计数的错误。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1. 升序排行</span><br><span class="line">&quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;genres&quot; : &#123;</span><br><span class="line">            &quot;terms&quot; : &#123;</span><br><span class="line">                &quot;field&quot; : &quot;genre&quot;,</span><br><span class="line">                &quot;order&quot; : &#123; &quot;_count&quot; : &quot;asc&quot; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">2. 按照key排序</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;genres&quot; : &#123;</span><br><span class="line">            &quot;terms&quot; : &#123;</span><br><span class="line">                &quot;field&quot; : &quot;genre&quot;,</span><br><span class="line">                &quot;order&quot; : &#123; &quot;_key&quot; : &quot;asc&quot; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">3.</span> </span><br></pre></td></tr></table></figure>
<h3 id="min-doc-count"><a href="#min-doc-count" class="headerlink" title="min_doc_count"></a>min_doc_count</h3></li>
<li><p>使用min_doc_count参数的时候，只会返回大于数值的的匹配分组桶</p>
<h3 id="include-exclude"><a href="#include-exclude" class="headerlink" title="include exclude"></a>include exclude</h3></li>
<li><p>包含 和 排除 的分组key</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;aggs&quot;: &#123;</span><br><span class="line">  &quot;heshen_terms&quot;: &#123;</span><br><span class="line">    &quot;terms&quot;: &#123;</span><br><span class="line">      &quot;field&quot;: &quot;type&quot;,</span><br><span class="line">      &quot;size&quot;: 5,</span><br><span class="line">      &quot;shard_size&quot;: 5, </span><br><span class="line">      &quot;show_term_doc_count_error&quot;: true,</span><br><span class="line">      &quot;include&quot;: [&quot;Product A&quot;,&quot;Product B&quot;],</span><br><span class="line">      &quot;exclude&quot;: [&quot;Product A&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Missing-value"><a href="#Missing-value" class="headerlink" title="Missing value"></a>Missing value</h3></li>
<li><p>文档缺少值的时候的处理</p>
</li>
</ul>
<h1 id="管道聚合"><a href="#管道聚合" class="headerlink" title="管道聚合"></a>管道聚合</h1><p>概念： 支持对聚合分析的结果，再一次进行聚合分析     </p>
<p>管道聚合的结果会添加到返回当中，根据位置不同分为两类：  <br>**Sibling 同级    **<br>包括：max_bucket,min_bucket ,avg_bucket ,sum_bucket , stats_bucket , percentiles_bucket<br>**Parent 父级 **     <br>包括：derivative （求导） ，cumulative_sum （累计求和） ，moving_fn（滑动窗口） </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.rcode.top/2021/05/16/es/es3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://z3.ax1x.com/2021/05/30/2VQ8M9.jpg">
      <meta itemprop="name" content="河神">
      <meta itemprop="description" content="你可以跑,但你不能躲">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rick-Code">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/16/es/es3/" class="post-title-link" itemprop="url">ES搜索</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-16 00:00:00" itemprop="dateCreated datePublished" datetime="2021-05-16T00:00:00+08:00">2021-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-31 15:30:02" itemprop="dateModified" datetime="2021-05-31T15:30:02+08:00">2021-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/es/" itemprop="url" rel="index"><span itemprop="name">es</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h1><h2 id="根据id查询"><a href="#根据id查询" class="headerlink" title="根据id查询"></a>根据id查询</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET heshen_test_v1/_doc/1</span><br></pre></td></tr></table></figure>
<h2 id="MGET查询"><a href="#MGET查询" class="headerlink" title="MGET查询"></a>MGET查询</h2><ul>
<li>可以查询不同索引的数据一同返回<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET _mget</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;docs&quot;</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;_index&quot;</span>:<span class="string">&quot;heshen_test_v1&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;_id&quot;</span>:<span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;_index&quot;</span>:<span class="string">&quot;heshen_test_v2&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;_id&quot;</span>:<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>可以返回不同字段的数据，<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET _mget</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;docs&quot;</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;_index&quot;</span>:<span class="string">&quot;heshen_test_v1&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;_id&quot;</span>:<span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;_source&quot;</span>: [<span class="string">&quot;itemName&quot;</span>,<span class="string">&quot;id&quot;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;_index&quot;</span>:<span class="string">&quot;heshen_test_v2&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;_id&quot;</span>:<span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;_source&quot;</span>: [<span class="string">&quot;weight&quot;</span>,<span class="string">&quot;price&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Search-1"><a href="#Search-1" class="headerlink" title="Search"></a>Search</h1><table>
<thead>
<tr>
<th>语法</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>_search</td>
<td>全部索引</td>
</tr>
<tr>
<td>_all/_search</td>
<td>全部索引</td>
</tr>
<tr>
<td>heshen_test_v1/_search</td>
<td>heshen_test_v1</td>
</tr>
<tr>
<td>heshen_test_v1,heshen_test_v2/_search</td>
<td>heshen_test_v1,heshen_test_v2</td>
</tr>
<tr>
<td>heshen_test*/_search</td>
<td>heshen_test开头的索引</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="Url查询-用的不多"><a href="#Url查询-用的不多" class="headerlink" title="Url查询(用的不多)"></a>Url查询(用的不多)</h2><ul>
<li><p>使用q表示查询字符串</p>
</li>
<li><p>size 返回条数</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/6.8/search-uri-request.html">doc</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET heshen_test_v1/_search?q=weight:13&amp;&amp;size=10</span><br></pre></td></tr></table></figure>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="Request-Body-查询"><a href="#Request-Body-查询" class="headerlink" title="Request Body 查询"></a>Request Body 查询</h2><p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/6.8/search-request-body.html">doc</a></p>
<h3 id="格式以及返回"><a href="#格式以及返回" class="headerlink" title="格式以及返回"></a>格式以及返回</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">req:</span><br><span class="line">GET heshen_test_v1/_search?search_type=query_then_fetch</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;from&quot;</span>: <span class="number">1</span>, </span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">&quot;timeout&quot;</span>: <span class="string">&quot;1s&quot;</span>, </span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;_id&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;value&quot;</span>: <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span> : <span class="number">1</span>, <span class="comment">//花费的时间</span></span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> : <span class="literal">false</span>, <span class="comment">//是否超时</span></span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;<span class="comment">//分片</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">3</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">3</span>,</span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">1</span>,<span class="comment">//总文档数</span></span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span> : <span class="number">1.0</span>,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span> : [<span class="comment">//结果集</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;heshen_test_v1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span> : <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h1 id="Query-DSL"><a href="#Query-DSL" class="headerlink" title="Query DSL"></a>Query DSL</h1><h2 id="Query-和-Filter"><a href="#Query-和-Filter" class="headerlink" title="Query 和 Filter"></a>Query 和 Filter</h2></li>
<li><p>区别在于 filter 不计算相关性，只关心是否命中条件</p>
</li>
<li><p>计算相关性需要计算匹配分值，消耗性能。而且匹配的分值都是实时计算，没有缓存</p>
</li>
<li><p>es会自动缓存 filter ，以提高性能，所以应该尽量使用过滤查询以减少性能消耗</p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123; </span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123; </span><br><span class="line">      <span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">        &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;title&quot;</span>:   <span class="string">&quot;Search&quot;</span>        &#125;&#125;, </span><br><span class="line">        &#123; <span class="attr">&quot;match&quot;</span>: &#123; <span class="attr">&quot;content&quot;</span>: <span class="string">&quot;Elasticsearch&quot;</span> &#125;&#125;  </span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: [ </span><br><span class="line">        &#123; <span class="attr">&quot;term&quot;</span>:  &#123; <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;published&quot;</span> &#125;&#125;, </span><br><span class="line">        &#123; <span class="attr">&quot;range&quot;</span>: &#123; <span class="attr">&quot;publish_date&quot;</span>: &#123; <span class="attr">&quot;gte&quot;</span>: <span class="string">&quot;2015-01-01&quot;</span> &#125;&#125;&#125; </span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Full-text-query-全文搜索"><a href="#Full-text-query-全文搜索" class="headerlink" title="Full text query  全文搜索"></a>Full text query  全文搜索</h2><ul>
<li>全文检索，被查询的字段需要被分析</li>
<li>查询条件也会被分析</li>
</ul>
<p><img src="https://heshen-1257140474.cos.ap-nanjing.myqcloud.com/serch1.png" alt="image.png"></p>
<h3 id="Match-Query"><a href="#Match-Query" class="headerlink" title="Match Query"></a>Match Query</h3><ul>
<li><p>最基本的全文索引查询，支持单词查询，模糊查询，短语查询，近义词查询</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET heshen_text/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;中国&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Match-Pharse-Query"><a href="#Match-Pharse-Query" class="headerlink" title="Match Pharse Query"></a>Match Pharse Query</h3></li>
<li><p>类似match，专门查询短语，可以指定短语的间隔</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET heshen_text/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_phrase&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;这中国&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;slop&quot;</span>: <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Match-Phrase-Prefix-Query"><a href="#Match-Phrase-Prefix-Query" class="headerlink" title="Match Phrase Prefix Query"></a>Match Phrase Prefix Query</h3></li>
<li><p>类似于短语的查询，但是最后一个单词是前缀匹配</p>
</li>
<li><p>不如 is t 可以命中 this  is a test </p>
<h2 id="Term-query-结构化搜索"><a href="#Term-query-结构化搜索" class="headerlink" title="Term query  结构化搜索"></a>Term query  结构化搜索</h2></li>
<li><p>精确匹配查询，查询条件不会被分析</p>
</li>
<li><p>通过用于结构化的数据，</p>
</li>
<li><p>对于被分析过的字段也可以使用，不过匹配的是分词之后的单词</p>
</li>
</ul>
<p><img src="https://heshen-1257140474.cos.ap-nanjing.myqcloud.com/search2.png" alt="image.png"></p>
<h3 id="Term-最常用"><a href="#Term-最常用" class="headerlink" title="Term (最常用)"></a>Term (最常用)</h3><ul>
<li><p>单值等于匹配</p>
</li>
<li><p>类似于 = </p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET _search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;term&quot;</span> : &#123; <span class="attr">&quot;user&quot;</span> : <span class="string">&quot;Kimchy&quot;</span> &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Terms-最常用"><a href="#Terms-最常用" class="headerlink" title="Terms (最常用)"></a>Terms (最常用)</h3></li>
<li><p>多值匹配</p>
</li>
<li><p>类似于 IN</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;terms&quot;</span> : &#123; <span class="attr">&quot;user&quot;</span> : [<span class="string">&quot;kimchy&quot;</span>, <span class="string">&quot;elasticsearch&quot;</span>]&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Terms-Set"><a href="#Terms-Set" class="headerlink" title="Terms Set"></a>Terms Set</h3></li>
<li><p>可以指定最小匹配数量</p>
<h3 id="Range-常用"><a href="#Range-常用" class="headerlink" title="Range (常用)"></a>Range (常用)</h3></li>
<li><p>可以按照区间查询日期，数字，以及区间类型</p>
</li>
<li><p>类似于 between </p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET _search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;range&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;age&quot;</span> : &#123;</span><br><span class="line">                <span class="attr">&quot;gte&quot;</span> : <span class="number">10</span>,</span><br><span class="line">                <span class="attr">&quot;lte&quot;</span> : <span class="number">20</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Exists-常用"><a href="#Exists-常用" class="headerlink" title="Exists (常用)"></a>Exists (常用)</h3></li>
<li><p>存在查询，返回字段不是 null  或者 [] 空数组的文档</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;exists&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;user&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配合 bool 查询的must_not可以实现 不存在 条件</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;must_not&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;exists&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;user&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模糊搜索"><a href="#模糊搜索" class="headerlink" title="模糊搜索"></a>模糊搜索</h3><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>wildcard</td>
<td>根据占位符的内容进行匹配</td>
<td></td>
</tr>
<tr>
<td>prefix</td>
<td>前缀匹配</td>
<td></td>
</tr>
<tr>
<td>fuzzy</td>
<td>相似度匹配</td>
<td></td>
</tr>
<tr>
<td>regexp</td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="wildcard-通配符查询"><a href="#wildcard-通配符查询" class="headerlink" title="wildcard  通配符查询"></a>wildcard  通配符查询</h4><ul>
<li><p>通配符  *  ,类似于  wildcard like “X%”</p>
</li>
<li><p>匹配0个或者多个字符</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;wildcard&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;user&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;X*&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>占位符  ? ,,类似于  wildcard like “X_”</p>
</li>
<li><p>匹配单个字符</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;wildcard&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;user&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;X?&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="prefix-前缀匹配"><a href="#prefix-前缀匹配" class="headerlink" title="prefix 前缀匹配"></a>prefix 前缀匹配</h4></li>
<li><p>查找指定字段包含以指定确切前缀开头的术语的文档</p>
</li>
<li><p>类似于  wildcard like “X%”</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123; <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;wildcard&quot;</span> : &#123; <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;X&quot;</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fuzzy-误拼写模糊匹配"><a href="#fuzzy-误拼写模糊匹配" class="headerlink" title="fuzzy 误拼写模糊匹配"></a>fuzzy 误拼写模糊匹配</h4></li>
<li><p>使用基于Levenshtein编辑距离实现的相似搜索</p>
</li>
<li><p>Levenshtein编辑距离是什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Levenshtein 距离，又称编辑距离，指的是两个字符串之间，由一个转换成另一个所需的最少编辑操作次数。</span><br><span class="line">许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。</span><br><span class="line">编辑距离的算法是首先由俄国科学家Levenshtein提出的，故又叫Levenshtein Distance</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;fuzzy&quot; : &#123;</span><br><span class="line">            &quot;user&quot; : &#123;</span><br><span class="line">                &quot;value&quot;: &quot;ki&quot;,</span><br><span class="line">                &quot;boost&quot;: 1.0,</span><br><span class="line">                &quot;fuzziness&quot;: 2,</span><br><span class="line">                &quot;prefix_length&quot;: 0,</span><br><span class="line">                &quot;max_expansions&quot;: 100</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fuzziness：最大编辑距离【一个字符串要与另一个字符串相同必须更改的一个字符数】。默认为AUTO。</span><br><span class="line"></span><br><span class="line">prefix_length：不会被“模糊化”的初始字符数。这有助于减少必须检查的术语数量。默认为0。</span><br><span class="line"></span><br><span class="line">max_expansions：fuzzy查询将扩展到的最大术语数。默认为50。</span><br><span class="line"></span><br><span class="line">transpositions：是否支持模糊转置（ab→ ba）。默认值为false。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Compound-复合查询"><a href="#Compound-复合查询" class="headerlink" title="Compound  复合查询"></a>Compound  复合查询</h2><h3 id="Bool-最常用"><a href="#Bool-最常用" class="headerlink" title="Bool (最常用)"></a>Bool (最常用)</h3><ul>
<li>最常用的组合查询，包含 must  ，should ，must_not ，filter ,可以嵌套</li>
<li>bool.filter的分值计算, 在filter子句查询中，分值将会都返回0。分值会受特定的查询影响。<h4 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h4><table>
<thead>
<tr>
<th>类型</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>must</td>
<td>返回的文档必须满足must子句的条件，并且参与计算分值</td>
</tr>
<tr>
<td>should</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<ol>
<li>返回的文档可能满足should子句的条件。在一个Bool查询中，如果没有must或者filter，有一个或者多个should子句，那么只要满足一个就可以返回。minimum_should_match参数定义了至少满足几个子句</li>
<li>如果一个查询既有filter又有should，那么至少包含一个should子句。<br>|<br>| must_not | 返回的文档必须不满足must_not定义的条件。&gt;<br>|<br>| filter | 返回的文档必须满足filter子句的条件。但是不会像Must一样，参与计算分值 |</li>
</ol>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">POST _search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;term&quot;</span> : &#123; <span class="attr">&quot;user&quot;</span> : <span class="string">&quot;kimchy&quot;</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;term&quot;</span> : &#123; <span class="attr">&quot;tag&quot;</span> : <span class="string">&quot;tech&quot;</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;must_not&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;range&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;age&quot;</span> : &#123; <span class="attr">&quot;gte&quot;</span> : <span class="number">10</span>, <span class="attr">&quot;lte&quot;</span> : <span class="number">20</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;should&quot;</span> : [</span><br><span class="line">        &#123; <span class="attr">&quot;term&quot;</span> : &#123; <span class="attr">&quot;tag&quot;</span> : <span class="string">&quot;wow&quot;</span> &#125; &#125;,</span><br><span class="line">        &#123; <span class="attr">&quot;term&quot;</span> : &#123; <span class="attr">&quot;tag&quot;</span> : <span class="string">&quot;elasticsearch&quot;</span> &#125; &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;minimum_should_match&quot;</span> : <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他不重要的复合查询"><a href="#其他不重要的复合查询" class="headerlink" title="其他不重要的复合查询"></a>其他不重要的复合查询</h2><h3 id="constant-score-query"><a href="#constant-score-query" class="headerlink" title="constant_score query"></a>constant_score query</h3><ul>
<li><p>不计算得分，可以指定一个指定的常量分值</p>
<h3 id="dis-max-query"><a href="#dis-max-query" class="headerlink" title="dis_max query"></a>dis_max query</h3></li>
<li><p>对多个自查询取最高的得分</p>
</li>
<li><p>如果自查询分值想近，还有加成的选项</p>
<h3 id="function-score-query"><a href="#function-score-query" class="headerlink" title="function_score query"></a>function_score query</h3></li>
<li><p>可以自定义评分的查询</p>
<h3 id="boosting-query"><a href="#boosting-query" class="headerlink" title="boosting query"></a>boosting query</h3></li>
<li><p>可以对子查询进行加分，和减分的操作</p>
</li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>排序是针对字段的原始内容进行的，倒排索引在排序中是没有用处的。<br>排序需要使用正排索引，通过文档id和字段快速得到原始的文档内容。<br> ES对于排序，有两种方式：  </p>
<ul>
<li>Field Data 支持 </li>
<li>Doc Values (列式存储，对Text无效)     </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.rcode.top/2021/05/11/es/es2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://z3.ax1x.com/2021/05/30/2VQ8M9.jpg">
      <meta itemprop="name" content="河神">
      <meta itemprop="description" content="你可以跑,但你不能躲">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rick-Code">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/11/es/es2/" class="post-title-link" itemprop="url">ES索引操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-11 00:00:00" itemprop="dateCreated datePublished" datetime="2021-05-11T00:00:00+08:00">2021-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-31 15:30:01" itemprop="dateModified" datetime="2021-05-31T15:30:01+08:00">2021-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/es/" itemprop="url" rel="index"><span itemprop="name">es</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h2><h3 id="创建索引-文档"><a href="#创建索引-文档" class="headerlink" title="创建索引 文档"></a>创建索引 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/6.8/indices-create-index.html">文档</a></h3><ul>
<li>基本语法 <code> PUT twitter</code></li>
<li>索引名称限制：<ul>
<li>只能小写</li>
<li>不能包括 <code>\</code>, <code>/</code>, <code>*</code>, <code>?</code>, <code>&quot;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>|</code>, 空格 , <code>,</code>, <code>#</code></li>
<li>不能包括冒号，7.0之前可以用，7.0之后不可以</li>
<li>不能使用 + - 开头</li>
<li>不能包括 . 或者 ..</li>
<li>不能超过 255 个字节</li>
</ul>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">PUT heshen_test_v1</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;number_of_replicas&quot;</span>: <span class="number">2</span>, <span class="comment">//副本数2</span></span><br><span class="line">      <span class="attr">&quot;number_of_shards&quot;</span>: <span class="number">3</span>,<span class="comment">//分片3</span></span><br><span class="line">      <span class="attr">&quot;max_result_window&quot;</span>: <span class="number">1000000</span>, <span class="comment">//最大返回数据 1000000</span></span><br><span class="line">      <span class="attr">&quot;write&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;wait_for_active_shards&quot;</span> : <span class="string">&quot;2&quot;</span> <span class="comment">//等待多少分片执行完成</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123; <span class="comment">//映射字段</span></span><br><span class="line">    <span class="attr">&quot;_doc&quot;</span>:&#123; <span class="comment">// 约定都使用_doc ,可以不实用_doc，但是不能使用_开头，</span></span><br><span class="line">        <span class="attr">&quot;properties&quot;</span>:&#123;</span><br><span class="line">           <span class="attr">&quot;itemName&quot;</span>:&#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span></span><br><span class="line">           &#125;,</span><br><span class="line">           <span class="attr">&quot;weight&quot;</span>:&#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;scaled_float&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;scaling_factor&quot;</span>: <span class="number">100</span></span><br><span class="line">           &#125;,</span><br><span class="line">           <span class="attr">&quot;price&quot;</span>:&#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;long&quot;</span></span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;aliases&quot;</span>: &#123;<span class="comment">//别名，用处很多</span></span><br><span class="line">    <span class="attr">&quot;heshen_test&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取索引"><a href="#获取索引" class="headerlink" title="获取索引"></a>获取索引</h3><ul>
<li><p><code>GET heshen_test</code> 获取指定索引信息</p>
</li>
<li><p><code>GET * </code> 获取所有的索引信息</p>
</li>
<li><p><code>GET _all</code>  获取所有的索引信息</p>
</li>
<li><p><code>GET es_erp_purchase_*</code> 获取通配符匹配的索引信息</p>
<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3></li>
<li><p><code>DELETE heshen_test_v1</code></p>
</li>
<li><p>删除索引必须是索引名，不能通过别名删除索引 </p>
<h3 id="是否存在"><a href="#是否存在" class="headerlink" title="是否存在"></a>是否存在</h3></li>
<li><p><code>HEAD heshen_test</code> 索引是否存在</p>
<h3 id="打开-关闭索引"><a href="#打开-关闭索引" class="headerlink" title="打开/关闭索引"></a>打开/关闭索引</h3></li>
<li><p><code>POST heshen_test_v1/_close</code></p>
</li>
<li><p><code>POST heshen_test_v1/_open</code></p>
</li>
<li><p>被关闭的索引禁止读写,只能展示元信息</p>
<h3 id="索引统计"><a href="#索引统计" class="headerlink" title="索引统计"></a>索引统计</h3></li>
<li><p><code>GET`` ``/``_stats</code></p>
</li>
<li><p><code>GET /heshen_test_v1/_stats</code></p>
<h3 id="索引别名"><a href="#索引别名" class="headerlink" title="索引别名"></a>索引别名</h3><p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/6.8/indices-aliases.html">文档</a></p>
<h4 id="创建修改别名"><a href="#创建修改别名" class="headerlink" title="创建修改别名"></a>创建修改别名</h4></li>
<li><p>带有过滤器的别名提供了创建相同索引的不同“视图”的简单方法。过滤器可以使用查询DSL定义，并应用于所有搜索、计数、按查询删除以及类似于此别名的操作。</p>
</li>
<li><p>在创建别名时可以指定路由值。</p>
</li>
<li><p>如果一个别名只映射了一个真实索引，则可以使用别名进行index api(即索引文档，写文档)，但如果一个别名同一时间映射了多个索引，默认是不能直接使用别名进行索引文档，因为ES不知道文档该发往哪个索引。可以使用is_write_index属性为一个别名下的其中一个索引指定为写索引，此时则可以直接使用别名进行index api的调用。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">POST _aliases</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;actions&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;add&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;heshen_test_v1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;alias&quot;</span>: <span class="string">&quot;heshen&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;is_write_index&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;routing&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;filter&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;remarks&quot;</span>: <span class="string">&quot;测试&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;add&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;heshen_test_v2&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;alias&quot;</span>: <span class="string">&quot;heshen&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除别名"><a href="#删除别名" class="headerlink" title="删除别名"></a>删除别名</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">POST _aliases</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;actions&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;remove&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;heshen_test_v2&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;alias&quot;</span>: <span class="string">&quot;heshen&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;remove&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;heshen_test_v1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;alias&quot;</span>: <span class="string">&quot;heshen&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Reindex"><a href="#Reindex" class="headerlink" title="Reindex"></a>Reindex</h3><p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/6.8/docs-reindex.html">文档</a></p>
</li>
<li><p>es的索引一旦创建，分片，以及字段类型都不允许修改，所以一般只能创建新的索引，然后把数据导入</p>
</li>
<li><p>reindex支持把数据从一个索引拷贝到另一个索引中</p>
</li>
<li><p>reindex不会复制索引的设置，包括mapping ,settings</p>
<h4 id="普通复制"><a href="#普通复制" class="headerlink" title="普通复制"></a>普通复制</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;heshen_test_v1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;heshen_test_v2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h4></li>
<li><p>在dest中 添加 version_type (见下文类型介绍 ) 字段可以实现根据版本进行复制</p>
</li>
<li><p>默认情况下，version冲突会终止reindex进程，可以通过 conflicts 属性来设置不结束，只统计冲突数量</p>
</li>
<li><p>在dest中 op_type 可以设置操作类型，可以设置只复制不存在的数据</p>
</li>
<li><p>可以通过 query属性来设置那些数据被复制</p>
</li>
<li><p>source的index 可以是一个列表 ，来将多个索引的数据复制到一个索引</p>
</li>
<li><p>source的 _source 可以设置只复制部分字段</p>
</li>
<li><p>可以用过 script 来修改文档 </p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">12</span>,<span class="comment">//只处理12条数据</span></span><br><span class="line">  <span class="attr">&quot;conflicts&quot;</span>: <span class="string">&quot;proceed&quot;</span>,<span class="comment">//冲突计数</span></span><br><span class="line">  <span class="attr">&quot;source&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;heshen_test_v1&quot;</span>, <span class="comment">//也可以是  &quot;index&quot;:[ &quot;heshen_test_v1&quot;,&quot; &quot;heshen_test_v3&quot;]</span></span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123; <span class="comment">//设置源数据那些数据需要复制</span></span><br><span class="line">      <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;weight&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;value&quot;</span>: <span class="number">12</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">   <span class="attr">&quot;_source&quot;</span>: [<span class="string">&quot;weight&quot;</span>, <span class="string">&quot;itemName&quot;</span>],<span class="comment">//只复制部分字段</span></span><br><span class="line">   <span class="attr">&quot;sort&quot;</span>: &#123; <span class="attr">&quot;date&quot;</span>: <span class="string">&quot;desc&quot;</span> &#125;,<span class="comment">//设置处理数据排序</span></span><br><span class="line">   <span class="attr">&quot;script&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;inline&quot;</span>: <span class="string">&quot;if (ctx._source.foo == &#x27;bar&#x27;) &#123;ctx._version++; ctx._source.remove(&#x27;foo&#x27;)&#125;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;lang&quot;</span>: <span class="string">&quot;painless&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;heshen_test_v2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;version_type&quot;</span>: <span class="string">&quot;external&quot;</span>, <span class="comment">//版本复制</span></span><br><span class="line">    <span class="attr">&quot;op_type&quot;</span>:<span class="string">&quot;create&quot;</span> <span class="comment">//只会创建不存在的数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="索引模板"><a href="#索引模板" class="headerlink" title="索引模板"></a>索引模板</h2><h3 id="索引模板是什么"><a href="#索引模板是什么" class="headerlink" title="索引模板是什么"></a>索引模板是什么</h3></li>
<li><p>索引模板是可以在创建一个新的索引的时候，自动应用的模板，包括设置和映射。</p>
</li>
<li><p>模板只在创建索引的时候使用，更改模板不会对现有索引产生影响</p>
</li>
<li><p>在创建的时候，自定义的设置，映射优先于 模板当中的。</p>
<h3 id="创建索引模板"><a href="#创建索引模板" class="headerlink" title="创建索引模板"></a>创建索引模板</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PUT _template/template_heshen</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;index_patterns&quot;</span>: [<span class="comment">//匹配模式</span></span><br><span class="line">    <span class="string">&quot;heshen*&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;order&quot;</span> : <span class="number">0</span>,<span class="comment">//优先级</span></span><br><span class="line">  <span class="attr">&quot;settings&quot;</span>: &#123;<span class="comment">//预定的设置</span></span><br><span class="line">    <span class="attr">&quot;index&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;number_of_replicas&quot;</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;number_of_shards&quot;</span>: <span class="number">3</span>,</span><br><span class="line">      <span class="attr">&quot;max_result_window&quot;</span>: <span class="number">1000000</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;<span class="comment">//预定的mappings</span></span><br><span class="line">    <span class="attr">&quot;_doc&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;created_name&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="number">123</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除索引模板"><a href="#删除索引模板" class="headerlink" title="删除索引模板"></a>删除索引模板</h3></li>
<li><p><code>DELETE`` ``/``_template/template_heshen</code></p>
<h3 id="获取索引模板"><a href="#获取索引模板" class="headerlink" title="获取索引模板"></a>获取索引模板</h3></li>
<li><p><code>GET /_template/template_heshen</code></p>
<h3 id="模板是否存在"><a href="#模板是否存在" class="headerlink" title="模板是否存在"></a>模板是否存在</h3></li>
<li><p><code>HEAD /_template/template_heshen</code></p>
<h3 id="模板匹配"><a href="#模板匹配" class="headerlink" title="模板匹配"></a>模板匹配</h3></li>
<li><p>多个模板可以匹配一个索引，多个相同的配置根据order字段来确定使用那个</p>
</li>
</ul>
<h2 id="Mapping操作"><a href="#Mapping操作" class="headerlink" title="Mapping操作"></a>Mapping操作</h2><h3 id="更新Mapping"><a href="#更新Mapping" class="headerlink" title="更新Mapping"></a>更新Mapping</h3><ul>
<li><p>映射已经创建后，一般不可以更改,除了更改子对象的字段，或者 ignore_above 属性</p>
</li>
<li><p>可以新增一个字段映射</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT heshen_test_v1/_mapping/_doc</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;properties&quot;</span>:&#123;</span><br><span class="line">     <span class="attr">&quot;img&quot;</span>:&#123;</span><br><span class="line">       <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;keyword&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>也可以批量添加字段映射</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT /twitter-1,twitter-2/_mapping/_doc </span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;user_name&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取Mapping"><a href="#获取Mapping" class="headerlink" title="获取Mapping"></a>获取Mapping</h3></li>
<li><p><code>GET /heshen_test_v1/_mapping</code> 获取整个Mapping信息</p>
</li>
<li><p><code>GET /heshen_test_v1/_mapping/_doc</code></p>
</li>
<li><p><code>GET /heshen_test_v1/_mapping/field/img</code> 获取某个字段的映射</p>
</li>
</ul>
<h2 id="Settings操作"><a href="#Settings操作" class="headerlink" title="Settings操作"></a>Settings操作</h2><h3 id="更新Settings-文档"><a href="#更新Settings-文档" class="headerlink" title="更新Settings 文档"></a>更新Settings <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/6.8/indices-update-settings.html">文档</a></h3><ul>
<li><p>注意分片数不可以修改</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT /heshen_test_v1/_settings</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;index&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;number_of_replicas&quot;</span> : <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="获取Settings"><a href="#获取Settings" class="headerlink" title="获取Settings"></a>获取Settings</h3></li>
<li><p><code>GET heshen_test_v1/_settings</code></p>
</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="文档-Document"><a href="#文档-Document" class="headerlink" title="文档 Document"></a>文档 Document</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><h4 id="指定id插入，如果存在则是更新"><a href="#指定id插入，如果存在则是更新" class="headerlink" title="指定id插入，如果存在则是更新"></a>指定id插入，如果存在则是更新</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT heshen_test_v1/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;itemName&quot;</span>: <span class="string">&quot;C货2&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;weight&quot;</span>: <span class="number">12</span>,</span><br><span class="line">  <span class="attr">&quot;price&quot;</span>:<span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="es自动生成id-（使用post代替put）"><a href="#es自动生成id-（使用post代替put）" class="headerlink" title="es自动生成id （使用post代替put）"></a>es自动生成id （使用post代替put）</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST heshen_test_v1/_doc/2</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure>
<h4 id="指定操作类型-指定类型为创建，如果id已经存在，就会返回失败"><a href="#指定操作类型-指定类型为创建，如果id已经存在，就会返回失败" class="headerlink" title="指定操作类型,指定类型为创建，如果id已经存在，就会返回失败"></a>指定操作类型,指定类型为创建，如果id已经存在，就会返回失败</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT heshen_test_v1/_doc/4/_create</span><br><span class="line">&#123;...&#125;</span><br><span class="line"></span><br><span class="line">PUT heshen_test_v1/_doc/4?op_type=create</span><br><span class="line">&#123;...&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="超时时间"><a href="#超时时间" class="headerlink" title="超时时间"></a>超时时间</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUT heshen_test_v1/_doc/4?timeout=10ms</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure>
<h4 id="版本号-乐观锁更新"><a href="#版本号-乐观锁更新" class="headerlink" title="版本号-乐观锁更新"></a>版本号-乐观锁更新</h4><ul>
<li>默认es采用内部版本控制，每一次更新版本号+1，我们可以使用version_type=external 来启用外部版本号功能。</li>
<li>请求的版本号需要是非负正整数</li>
<li>默认es的内部版本控制为一定要与当前版本号相同才能更新成功</li>
<li>（启用之后，之后好像就不用在每次带version_type）<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT heshen_test_v1/_doc/2?version=17</span><br><span class="line">&#123;...&#125;</span><br><span class="line">当文档version=17的时候保存成功</span><br><span class="line"></span><br><span class="line">PUT heshen_test_v1/_doc/2?version=17&amp;version_type=external_gte</span><br><span class="line">&#123;...&#125;</span><br><span class="line">当文档version&lt;=17的时候成功</span><br><span class="line"></span><br><span class="line">PUT heshen_test_v1/_doc/2?version=17&amp;version_type=external</span><br><span class="line">&#123;...&#125;</span><br><span class="line">当文档version&lt;17的时候成功</span><br></pre></td></tr></table></figure>
<h4 id="version-type类型"><a href="#version-type类型" class="headerlink" title="version_type类型"></a>version_type类型</h4>internal ：完全相同才成功<br>external_gt || external :当请求的版本号大于的时候才成功<br>external_gte ：当请求的版本号大于等于的时候才成功</li>
</ul>
<h4 id="自动创建索引。"><a href="#自动创建索引。" class="headerlink" title="自动创建索引。"></a>自动创建索引。</h4><p>如果索引不存在，自动创建索引，并且应用索引模板，字段类型es会动态生成。可以通过action.auto_create_index 来控制。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PUT _cluster/settings</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;persistent&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;action.auto_create_index&quot;</span>: <span class="string">&quot;heshen*&quot;</span><span class="comment">//只允许某些索引创建 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT _cluster/settings</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;persistent&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;action.auto_create_index&quot;</span>: <span class="string">&quot;false&quot;</span> <span class="comment">//全部不允许</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT _cluster/settings</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;persistent&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;action.auto_create_index&quot;</span>: <span class="string">&quot;true&quot;</span> <span class="comment">//全部允许</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><h4 id="基于id部分字段更新"><a href="#基于id部分字段更新" class="headerlink" title="基于id部分字段更新"></a>基于id部分字段更新</h4><ul>
<li><p>存在的字段会被更新</p>
</li>
<li><p>不存在的字段会添加，映射不存在的会自动添加映射</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST heshen_test_v1/_doc/1/_update</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;doc&quot;</span>: &#123;</span><br><span class="line">     <span class="attr">&quot;itemName&quot;</span>:<span class="string">&quot;C货112&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基于脚本更新"><a href="#基于脚本更新" class="headerlink" title="基于脚本更新"></a>基于脚本更新</h4></li>
<li><p>基于es的script脚本进行更新</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">POST heshen_test_v1/_doc/1/_update</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;script&quot;</span>: &#123;</span><br><span class="line">     <span class="attr">&quot;source&quot;</span>:<span class="string">&quot;ctx._source.remarks=&#x27;和天下&#x27;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST heshen_test_v1/_doc/1/_update</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;script&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;source&quot;</span>: <span class="string">&quot;ctx._source.weight=params.count&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lang&quot;</span>: <span class="string">&quot;painless&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;params&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;count&quot;</span>: <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Upsert"><a href="#Upsert" class="headerlink" title="Upsert"></a>Upsert</h4></li>
<li><p>普通更新如果文档不存在，会报错</p>
</li>
<li><p>而加了upsert之后，如果文档不存在，会初始化文档</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST heshen_test_v1/_doc/6/_update</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;script&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;source&quot;</span>: <span class="string">&quot;ctx._source.weight=params.count&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lang&quot;</span>: <span class="string">&quot;painless&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;params&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;count&quot;</span>: <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;upsert&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;itemName&quot;</span>: <span class="string">&quot;C货2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;weight&quot;</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="attr">&quot;price&quot;</span>: <span class="number">20</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="更新基于条件"><a href="#更新基于条件" class="headerlink" title="更新基于条件"></a>更新基于条件</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST heshen_test_v1/_update_by_query</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;script&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;source&quot;</span>: <span class="string">&quot;ctx._source.remarks=ctx._source.remarks+&#x27;*&#x27;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lang&quot;</span>: <span class="string">&quot;painless&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;_id&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;1&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3></li>
</ul>
<h3 id="如何使用脚本"><a href="#如何使用脚本" class="headerlink" title="如何使用脚本"></a>如何使用脚本</h3><p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/6.8/modules-scripting-using.html">链接</a></p>
<h4 id="脚本构成"><a href="#脚本构成" class="headerlink" title="脚本构成"></a>脚本构成</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;script&quot;: &#123;</span><br><span class="line">  &quot;lang&quot;:   &quot;...&quot;,  //脚本使用的语言 默认为 painless </span><br><span class="line">  &quot;source&quot; | &quot;id&quot;: &quot;...&quot;, // </span><br><span class="line">  &quot;params&quot;: &#123; ... &#125; //参数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="搜索返回字段"><a href="#搜索返回字段" class="headerlink" title="搜索返回字段"></a>搜索返回字段</h4><ul>
<li><p>es在第一次执行脚本的时候会把他缓存起来，所以如果脚本里有参数的话，一般是要使用参数字段，而不是硬编码</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET heshen_test_v1/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;script_fields&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;weight_big&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;script&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;lang&quot;</span>:   <span class="string">&quot;expression&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;source&quot;</span>:<span class="string">&quot;doc[&#x27;weight&#x27;] * sp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;params&quot;</span>: &#123;</span><br><span class="line">           <span class="attr">&quot;sp&quot;</span>: <span class="number">100</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="操作数据"><a href="#操作数据" class="headerlink" title="操作数据"></a>操作数据</h4></li>
<li><p>在reindex 和 update_by_query 可以设置数据的属性，甚至删除数据</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">noop: 设置 ctx.op = “noop” 。如果你的脚本并没有对原来的doc做任何更改。这将导致 reindex 忽略该doc。这将在响应的 noop 中被展示。</span><br><span class="line"></span><br><span class="line">delete: 设置ctx.op = “delete”，如果你的脚本如此设定，target index中的该doc会被被删除。这将在响应的 deleted 中被展示。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h4 id="基于id进行删除"><a href="#基于id进行删除" class="headerlink" title="基于id进行删除"></a>基于id进行删除</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE heshen_test_v1/_doc/1</span><br></pre></td></tr></table></figure>
<h4 id="基于条件删除"><a href="#基于条件删除" class="headerlink" title="基于条件删除"></a>基于条件删除</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST heshen_test_v1/_delete_by_query</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;_id&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;1&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="Bulk-批量增删改"><a href="#Bulk-批量增删改" class="headerlink" title="Bulk 批量增删改"></a>Bulk 批量增删改</h3></li>
<li><p>bulk是es提供的一种批量增删改</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>除delete操作意外，所有的操作必须是<code>一对JSON</code> ，而且每个JSON<code>不能换行</code>，<code>相邻JSON必须换行</code>，</p>
</li>
<li><p>格式：</p>
</li>
</ul>
<p><code>POST _bulk</code><br><code>&#123; action: &#123; metadata &#125;&#125;</code><br><code>&#123; request body        &#125;</code><br><code>&#123; action: &#123; metadata &#125;&#125;</code><br><code>&#123; request body        &#125;</code></p>
<h4 id="操作类型"><a href="#操作类型" class="headerlink" title="操作类型"></a>操作类型</h4><ul>
<li><code>create</code> 如果文档不存在就创建，但如果文档存在就返回错误</li>
<li><code>index</code> 如果文档不存在就创建，如果文档存在就更新</li>
<li><code>update</code> 更新一个文档，如果文档不存在就返回错误</li>
<li><code>delete</code> 删除一个文档，如果要删除的文档id不存在，就返回错误<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST _bulk</span><br><span class="line">&#123;<span class="attr">&quot;index&quot;</span>:&#123;<span class="attr">&quot;_index&quot;</span>:<span class="string">&quot;heshen_test_v1&quot;</span>,<span class="attr">&quot;_type&quot;</span>:<span class="string">&quot;_doc&quot;</span>,<span class="attr">&quot;_id&quot;</span>:<span class="string">&quot;4&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="attr">&quot;_doc&quot;</span>:&#123;<span class="attr">&quot;itemName&quot;</span>:<span class="string">&quot;C货3&quot;</span>,<span class="attr">&quot;weight&quot;</span>:<span class="number">12</span>,<span class="attr">&quot;price&quot;</span>:<span class="number">20</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">POST heshen_test_v1/_doc/_bulk </span><br><span class="line">&#123;<span class="attr">&quot;delete&quot;</span>: &#123;<span class="attr">&quot;_id&quot;</span>: <span class="number">5</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
ps:在es的bulk操作中，可以把索引，type加在操作前面，这样在json中可以不写出 index ,type</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.rcode.top/2021/05/05/es/es1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://z3.ax1x.com/2021/05/30/2VQ8M9.jpg">
      <meta itemprop="name" content="河神">
      <meta itemprop="description" content="你可以跑,但你不能躲">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rick-Code">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/05/es/es1/" class="post-title-link" itemprop="url">ES基础知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-05 00:00:00" itemprop="dateCreated datePublished" datetime="2021-05-05T00:00:00+08:00">2021-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-31 15:29:59" itemprop="dateModified" datetime="2021-05-31T15:29:59+08:00">2021-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/es/" itemprop="url" rel="index"><span itemprop="name">es</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://heshen-1257140474.cos.ap-nanjing.myqcloud.com/image1.png" alt="image.png"></h3><h3 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node - 节点"></a>Node - 节点</h3><ul>
<li>即节点。节点是组成Elasticsearch集群的基本服务单元，集群中的每个运行中的Elasticsearch服务器都可称之为节点。</li>
<li>每个节点默认都可以参加master选举，可以禁止（比如配置比较低的机器）</li>
<li>每个节点都保存了集群的状态，但是只有master才可以修改<ul>
<li>集群状态：<ul>
<li><ol>
<li>所有节点的信息。</li>
</ol>
</li>
<li>2.所有的索引以及其相关的mapping和setting的信息</li>
<li><ol start="3">
<li>分片的路由信息</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>节点的类型：<ul>
<li>data :数据节点，可以存储数据</li>
<li>coordinating : 协调节点，接受客户端请求，每个节点默认都可以作为协调节点</li>
<li>Ingest: 预处理节点</li>
<li>hot/warm: 冷热节点</li>
</ul>
</li>
</ul>
<h3 id="Cluster-集群"><a href="#Cluster-集群" class="headerlink" title="Cluster - 集群"></a>Cluster - 集群</h3><ul>
<li>集群。Elasticsearch的集群是由具有相同cluster.name （默认值为elasticsearch）的一个或多个Elasticsearch节点组成的，各个节点协同工作，共享数据。同一个集群内节点的名字不能重复，但集群名称一定要相同。</li>
<li>在实际使用Elasticsearch集群时一般使用自定义集群名称，可以防止错误加入集群</li>
<li>集群状态： <ul>
<li>绿色 表示节点运行状态为健康状态。所有的主分片和副本分片都可以正常工作，集群100%健康。</li>
<li>黄色 表示节点的运行状态为预警状态。所有的主分片都可以正常工作，但至少有一个副本分片是不能正常工作的。此时集群依然可以正常工作，但集群的高可用性在某种程度上被弱化。</li>
<li>红色 表示集群无法正常使用。此时，集群中至少有一个分片的主分片及它的全部副本分片都不可正常工作。虽然集群的查询操作还可以进行，但是也只能返回部分数据（其他正常分片的数据可以返回），而分配到这个有问题分片上的写入请求将会报错，最终导致数据丢失。</li>
</ul>
</li>
</ul>
<h3 id="Shards-分片"><a href="#Shards-分片" class="headerlink" title="Shards - 分片"></a>Shards - 分片</h3><ul>
<li>对于同一个索引进行水平拆分，拆分后的每一个数据部分被称为一个分片，一般来说，会将每个分片放入不同的节点上</li>
<li>感觉和mysql的分表有点像，不同部分的数据存放到不同的数据片段中，所以也是，如果数量发生变化，自然需要把数据重新移动，所以es不允许修改分片数</li>
<li>索引创建的时候指定分片数量，分片的数量一旦确定就不能更改。</li>
<li>写入数据的时候，是通过路由来确定具体写入哪个分片中的</li>
<li>在Elasticsearch中，默认为一个索引创建5个主分片，并分别为每个主分片创建一个副本</li>
<li>一个分片就是一个 lucene 索引</li>
<li>分片越多搜索越慢</li>
</ul>
<h3 id="Replicas-副本-备份"><a href="#Replicas-副本-备份" class="headerlink" title="Replicas - 副本 备份"></a>Replicas - 副本 备份</h3><ul>
<li>副本是对主分片的备份，每个主分片可以有零个或多个副本，主分片和备份分片都可以对外提供数据查询服务</li>
<li>写入： 首先在主分片上完成数据的索引，然后数据会从主分片分发到备份分片上进行索引。</li>
<li>主分片不可用时，Elasticsearch会在备份分片中选举出一个分片作为主分片，从而避免数据丢失。</li>
<li>优点：增加集群可用性 ，缺点：如果分片过多，写操作时会增加数据同步的负担</li>
</ul>
<h3 id="Index-索引"><a href="#Index-索引" class="headerlink" title="Index - 索引"></a>Index - 索引</h3><ul>
<li><p>在Elasticsearch中，索引由一个和多个分片组成。在使用索引时，需要通过索引名称在集群内进行唯一标识。</p>
<h3 id="Mapping-映射"><a href="#Mapping-映射" class="headerlink" title="Mapping - 映射"></a>Mapping - 映射</h3></li>
<li><p>Mapping表示中保存了定义索引中字段（Field）的存储类型、分词方式、是否存储等信息，有点类似于关系数据库（如MySQL）中的表结构信息。</p>
</li>
<li><p>一个索引的Mapping一旦创建，若已经存储了数据，就不可修改了，但是我们可以增加一个新的Mapping </p>
<h3 id="Settings-配置"><a href="#Settings-配置" class="headerlink" title="Settings - 配置"></a>Settings - 配置</h3></li>
<li><p>Settings是对集群中索引的定义信息，比如一个索引默认的分片数、副本数等。</p>
<h3 id="Analyzer-分词"><a href="#Analyzer-分词" class="headerlink" title="Analyzer - 分词"></a>Analyzer - 分词</h3></li>
<li><p> Analyzer表示的是字段分词方式的定义</p>
<h3 id="Type-类型-（6-2中只能包含1个type-7移除了-type的概念）"><a href="#Type-类型-（6-2中只能包含1个type-7移除了-type的概念）" class="headerlink" title="~~Type - 类型 ~~（6.2中只能包含1个type ,7移除了 type的概念）"></a>~~Type - 类型 ~~（6.2中只能包含1个type ,7移除了 type的概念）</h3></li>
<li><p>type就是在一个索引可以创建多个Mapping，在老的版本有把索引比喻成数据库，type比喻成表的说法。</p>
<h4 id="为什么要移除Type呢"><a href="#为什么要移除Type呢" class="headerlink" title="为什么要移除Type呢?"></a>为什么要移除Type呢?</h4></li>
<li><p>不同类型的“记录”存储在同一个index中，会影响lucene的压缩性能，简单说，影响效率</p>
<h3 id="Document-文档"><a href="#Document-文档" class="headerlink" title="Document  - 文档"></a>Document  - 文档</h3></li>
<li><p>索引中的每一条数据叫作一个文档，与关系数据库的使用方法类似，一条文档数据通过_id在Type内进行唯一标识。</p>
</li>
</ul>
<hr>
<h2 id="Elasticsearch的架构设计"><a href="#Elasticsearch的架构设计" class="headerlink" title="Elasticsearch的架构设计"></a>Elasticsearch的架构设计</h2><h3 id="服务发现以及选主"><a href="#服务发现以及选主" class="headerlink" title="服务发现以及选主"></a><strong>服务发现以及选主</strong></h3><ul>
<li><p>在集群中配置一个相同的集群名称（即cluster.name），就能将不同的节点连接到同一个集群</p>
</li>
<li><p>有四种方式的实现，默认ZenDiscovery，一般有两种方式加入，多播和单播</p>
<ul>
<li>多播：当节点并非集群的一部分时(比如节点只是刚刚启动或者重启 )，它会发送一个多播的ping请求到网段中，该请求只是用来通知所有能连接到节点和集群它已经准备好加入到集群中。</li>
<li>单播: 关闭多播，就可以安全地使用单播。当节点不是集群的一部分时(比如节点重启，启动或者由于某些错误从集群中断开)，节点会发送一个ping请求到事先设置好的地址中，来通知集群它已经准备好加入到集群中了。</li>
</ul>
</li>
<li><p>多播是自行到网段中寻找，单播是在指定地址中寻找</p>
</li>
<li><p>它会对所有可以成为master的节点（node.master: true）根据节点Id的字典排序，取第一个，暂且认为它是master节点。如果对某个节点的投票数达到一定的值（可以成为master节点数n/2+1  discovery.zen.minimum_master_nodes ）并且该节点自己也选举自己，那这个节点就是master。否则重新选举一直到满足上述条件。</p>
</li>
<li><p>如果只有一个本地节点，则主节点就是它自己。</p>
</li>
<li><p><strong>ES是如何避免脑裂现象的：</strong>可以通过discovery.zen.minimum_master_nodes这个参数的设置来避免脑裂，设置为(N/2)+1。</p>
</li>
<li><p><strong>ES的集群只有一个节点的话可以有副本吗？</strong>Elasticsearch 禁止同一个分片的主分片和副本分片在同一个节点上，所以如果是一个节点的集群是不能有副本的。其实在一个节点也就没有了副本的意义</p>
<h3 id="分片和路由"><a href="#分片和路由" class="headerlink" title="分片和路由"></a>分片和路由</h3></li>
<li><p>分片一旦确定，不能修改</p>
</li>
<li><p>对于并发的数据冲突，es采用乐观锁的方式来解决数据冲突，对于一些以最新数据为准的数据，可以采用自定义版本号的方式解决数据写入冲突。默认还可以设置乐观锁重试次数。</p>
</li>
<li><p>routing字段的取值默认是id字段或者是parent字段，采用routing字段在Hash后之后再与有分片的数量取模。这个值可以更改</p>
</li>
<li><p>shard_num = hash(_routing) % num_primary_shards</p>
</li>
<li><p>在做数据检索时，Elasticsearch默认会搜索所有分片上的数据，最后在主节点上汇总各个分片数据并进行排序处理后，返回最终的结果数据</p>
</li>
<li><p>通过路由的方式，还可以实现冷热数据架构 </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/6.8/mapping-routing-field.html">路由官方文档</a></p>
<h3 id="数据写入过程"><a href="#数据写入过程" class="headerlink" title="数据写入过程"></a>数据写入过程</h3><h4 id="1-分段存储"><a href="#1-分段存储" class="headerlink" title="1. 分段存储"></a>1. 分段存储</h4></li>
<li><p>使用原因： 索引是不可变的，为了实现数据的更新，需要通过增加新的补充索引来反映新近的修改，而不是直接重写整个倒排索引。</p>
</li>
<li><p>lucene 索引再次分割的最小单位</p>
</li>
<li><p>分段一经创建，便不会被修改</p>
</li>
<li><p>新增数据：新增一个数据段</p>
</li>
<li><p>删除数据：增加.del文件，被标记的可以查询到，但是在返回的时候会被移除</p>
</li>
<li><p>修改数据：先删除，然后新增新的数据段</p>
</li>
<li><p>优势： 不需要锁，从而提升Elasticsearch的读写性能，</p>
</li>
<li><p>缺点： 1. 分段越多 搜索越慢，因为需要过滤删除的数据 2. 在删除和更新数据时，存储空间会浪费</p>
<h4 id="2-延迟写策略"><a href="#2-延迟写策略" class="headerlink" title="2. 延迟写策略"></a>2. 延迟写策略</h4><p>  索引写入磁盘的过程是异步的</p>
<h5 id="基本方式"><a href="#基本方式" class="headerlink" title="基本方式"></a>基本方式</h5></li>
<li><p>每当有新的数据产生的时候，会将数据先写入内存当中，当数据到达一定程度的时候，或者到达刷新时间，会触发一次刷新（Refresh）操作。刷新操作将内存中的数据生成到一个新的分段上并缓存到文件缓存系统，稍后再被刷新到磁盘中并生成提交点。</p>
</li>
<li><p>当数据写入内存的时候，内存的数据并不是用段来存储的，因此不能提供检索功能。只有当数据由内存刷新到文件缓存系统的时候，并生成一个新的段的时候，才能被搜索到，而不用等刷新到磁盘</p>
</li>
<li><p>在es中，写入和打开一个新的段，叫做刷新。在默认情况下，每个分片会每秒自动刷新一次。这就是Elasticsearch能做到近实时搜索的原因，因为文档的变化并不是立即对搜索可见的，但会在一秒之内变为可见。也可以手动刷新。</p>
</li>
<li><p>可以通过 refresh_interval 来调整刷新频率， 当为-1的时候，表示关闭自动刷新</p>
</li>
</ul>
<ul>
<li>因为文件系统缓存有数据丢失的风险，所以引入了 Translog （事务日志）,所以最终的写入过程是这样的<ol>
<li>新文档被索引之后，先被写入内存中。为了防止数据丢失，Elasticsearch会追加一份数据到事务日志中。此时的新数据还不能被检索和查询。</li>
<li>当达到默认的刷新时间或内存中的数据达到一定量后，Elasticsearch会触发一次刷新，将内存中的数据以一个新段形式刷新到文件缓存系统中并清空内存。这时新段虽未被提交到磁盘，但已经可以对外提供文档的检索功能且不被修改。</li>
<li>随着新文档索引不断被写入，当日志数据大小超过某个值（如512MB），或者超过一定时间（如30 min）时，Elasticsearch会触发一次Flush，提交到硬盘。</li>
<li>生成提交点。日志文件被删除，创建一个空的新日志。</li>
</ol>
</li>
</ul>
<ol>
<li>新文档先被放入内存中，此时数据不能被检索</li>
</ol>
<p><img src="https://heshen-1257140474.cos.ap-nanjing.myqcloud.com/image2.png" alt="image.png"></p>
<ol start="2">
<li>默认刷新时间（1秒钟）到达，或者数据到达一定量的时候，会把内存中的数据创建一个新的段，此时数据可以被检索，但是此时数据还在内存。</li>
</ol>
<p><img src="https://heshen-1257140474.cos.ap-nanjing.myqcloud.com/image3.png" alt="image.png"></p>
<ol start="3">
<li>translog太大，或者默认_flush时间_（30分钟），进行_flush。段_数据被提交到硬盘当中，并且 translog 被清空</li>
</ol>
<p><img src="https://heshen-1257140474.cos.ap-nanjing.myqcloud.com/image4.png" alt="image.png"></p>
<h4 id="3-段合并"><a href="#3-段合并" class="headerlink" title="3. 段合并"></a>3. 段合并</h4><ul>
<li><p>因为分段的特点，es在增写删所以必然会产生很多的分段，对资源的消耗会剧增。而且这样的分段在查询出来数据之后，还需要与del，进行合并，这样的话，段越多，搜索越慢。所以就需要进行段合并。</p>
</li>
<li><p>段合并机制在后台定期进行，从而小的段被合并到大的段，然后这些大的段再被合并到更大的段。</p>
</li>
<li><p>段合并过程中，Elasticsearch会将那些旧的已删除文档从文件系统中清除。被删除的文档不会被拷贝到新的大段中，当然，在合并的过程中不会中断索引和搜索。</p>
</li>
<li><p>合并结束后，老的段会被删除，新的段被Flush到磁盘，同时写入一个包含新段且排除旧的和较小的段的新提交点。打开新的段之后，可以用来搜索。</p>
</li>
<li><p>默认情况下会对合并流程进行资源限制，防止影响搜索性能。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/6.8/index-modules-merge.html">官方文档</a></p>
<h3 id="WAL技术"><a href="#WAL技术" class="headerlink" title="WAL技术"></a>WAL技术</h3><h3 id="主副分片数据一致性"><a href="#主副分片数据一致性" class="headerlink" title="主副分片数据一致性"></a>主副分片数据一致性</h3></li>
<li><p>这个 不太确定</p>
</li>
<li><p>看有2.3的版本有说，后面的版本没有找到</p>
</li>
<li><p>同步：主分片处理完毕，然后同步进行数据同步到所有副本</p>
</li>
<li><p>异步：主分片处理完毕直接返回，副本 异步同步，会造成服务器压力过大</p>
</li>
</ul>
<h3 id="自动管理索引生命周期（ILM）"><a href="#自动管理索引生命周期（ILM）" class="headerlink" title="自动管理索引生命周期（ILM）"></a>自动管理索引生命周期（ILM）</h3><ul>
<li>把一个索引的生命周期定义为4个部分</li>
</ul>
<p><img src="https://heshen-1257140474.cos.ap-nanjing.myqcloud.com/image6.png" alt="image.png"></p>
<ul>
<li><strong>Hot</strong>：索引可写入，也可查询。</li>
<li><strong>Warm</strong>：索引不可写入，但可查询。</li>
<li><strong>Cold</strong>：索引不可写入，但很少被查询，查询的慢点也可接受。</li>
<li><strong>Delete</strong>：索引可被安全的删除</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.4/ilm-policy-definition.html">文档</a></li>
<li>策略：<ul>
<li>rollover：滚动存储，建立新索引，数据新增引入新索引</li>
<li>delete： 自动删除</li>
<li>shrink:   缩减分片，读的时候分片少可以减少内存消耗，写的时候分片多可以提速</li>
<li>readonly: 设置为只读</li>
<li>focemerge : 强行合并分段到一个很小的规模</li>
<li>freeze: 把索引关闭，不占用内存，只占用磁盘，不可以检索</li>
<li>allocate: 分片感知，可以用来冷热分离</li>
</ul>
</li>
</ul>
<ol>
<li>完整的策略配置：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.4/_full_policy.html#_full_policy">完整策略</a><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">PUT _ilm/policy/full_policy</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;policy&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;phases&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;hot&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;actions&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;rollover&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;max_age&quot;</span>: <span class="string">&quot;7d&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;max_size&quot;</span>: <span class="string">&quot;50G&quot;</span></span><br><span class="line">          &#125;<span class="comment">//当数量到达500g，或者存储时间超过7天的时候，就会进行滚动存储</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;warm&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;min_age&quot;</span>: <span class="string">&quot;30d&quot;</span>,<span class="comment">//进入这个阶段的条件</span></span><br><span class="line">        <span class="attr">&quot;actions&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;forcemerge&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;max_num_segments&quot;</span>: <span class="number">1</span> <span class="comment">//强行合并分段</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;shrink&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;number_of_shards&quot;</span>: <span class="number">1</span> <span class="comment">//分片缩减到1个</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;allocate&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;number_of_replicas&quot;</span>: <span class="number">2</span> <span class="comment">//增加两个副本</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;cold&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;min_age&quot;</span>: <span class="string">&quot;60d&quot;</span>,<span class="comment">//进入冷阶段条件</span></span><br><span class="line">        <span class="attr">&quot;actions&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;allocate&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;require&quot;</span>: &#123;<span class="comment">//将索引分配给 冷数据节点</span></span><br><span class="line">              <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cold&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;delete&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;min_age&quot;</span>: <span class="string">&quot;90d&quot;</span>,<span class="comment">//进行删除的条件</span></span><br><span class="line">        <span class="attr">&quot;actions&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;delete&quot;</span>: &#123;&#125;<span class="comment">//删除索引</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



































</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.rcode.top/2021/02/16/data/jpa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://z3.ax1x.com/2021/05/30/2VQ8M9.jpg">
      <meta itemprop="name" content="河神">
      <meta itemprop="description" content="你可以跑,但你不能躲">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rick-Code">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/16/data/jpa/" class="post-title-link" itemprop="url">jpa查询方式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-16 00:00:00" itemprop="dateCreated datePublished" datetime="2021-02-16T00:00:00+08:00">2021-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-16 14:09:03" itemprop="dateModified" datetime="2021-06-16T14:09:03+08:00">2021-06-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/data/" itemprop="url" rel="index"><span itemprop="name">data</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="jpa常用的查询方式"><a href="#jpa常用的查询方式" class="headerlink" title="jpa常用的查询方式"></a>jpa常用的查询方式</h1><p>jpa官方文档</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jpa/docs/2.1.5.RELEASE/reference/html/#jpa.query-methods.query-creation">https://docs.spring.io/spring-data/jpa/docs/2.1.5.RELEASE/reference/html/#jpa.query-methods.query-creation</a></p>
<p>项目地址：<br><a target="_blank" rel="noopener" href="https://github.com/MortyCode/jpaDemo">https://github.com/MortyCode/jpaDemo</a></p>
<h4 id="1-通过方法名来创建查询"><a href="#1-通过方法名来创建查询" class="headerlink" title="1.通过方法名来创建查询"></a>1.通过方法名来创建查询</h4><ol>
<li><p>使用字段的值进行条件查询，如Is,In,Like, Between等等。</p>
</li>
<li><p>使用and ,or 来进行条件拼接。</p>
</li>
<li><p>利用Pageable接口来进行分页，Sort 对象排序。</p>
</li>
<li><p>利用Distinct去重</p>
</li>
<li><p>利用OrderBy进行排序</p>
</li>
<li><p>利用 Top 和 First来获取限制数据</p>
<p> 查询方法的结果可以通过使用first或top关键字来限制，可以互换使用。也可以附加一个可选的数值，top或者first指定要返回的最大结果大小。如果省略该数字，该数字默认为1。</p>
</li>
<li><p>流式查询结果。jpa可以使用Java 8 Stream<T>作为返回类型的方式处理查询结果。但是需要在只读事物环境下进行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Account&gt; readAllByAgeIs(int i);</span><br></pre></td></tr></table></figure></li>
<li><p>异步查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Async</span><br><span class="line">Future&lt;User&gt; findByFirstname(String firstname);               </span><br><span class="line"></span><br><span class="line">@Async</span><br><span class="line">CompletableFuture&lt;User&gt; findOneByFirstname(String firstname); </span><br><span class="line"></span><br><span class="line">@Async</span><br><span class="line">ListenableFuture&lt;User&gt; findOneByLastname(String lastname);    </span><br></pre></td></tr></table></figure></li>
<li><p>可以通过@Lock(LockModeType.READ)来设置jpa锁</p>
<p> 乐观锁：<br> 1、OPTIMISTIC：它和READ锁模式相同，JPA 2.0仍然支持READ锁模式，但明确指出在新应用程序中推荐使用OPTIMISTIC。</p>
<p> 2、OPTIMISTIC_FORCE_INCREMENT：它和WRITE锁模式相同，JPA 2.0仍然支持WRITE锁模式，但明确指出在新应用程序中推荐使用OPTIMISTIC_FORCE_INCREMENT。 </p>
<p> 悲观锁模式：<br> 1、PESSIMISTIC_READ：只要事务读实体，实体管理器就锁定实体，直到事务完成锁才会解开，当你想使用重复读语义查询数据时使用这种锁模式，换句话说就是，当你想确保数据在连续读期间不被修改，这种锁模式不会阻碍其它事务读取数据。 </p>
<p> 2、PESSIMISTIC_WRITE：只要事务更新实体，实体管理器就会锁定实体，这种锁模式强制尝试修改实体数据的事务串行化，当多个并发更新事务出现更新失败几率较高时使用这种锁模式。 </p>
<p> 3、PESSIMISTIC_FORCE_INCREMENT：当事务读实体时，实体管理器就锁定实体，当事务结束时会增加实体的版本属性，即使实体没有修改。 </p>
</li>
</ol>
<h4 id="2-Query"><a href="#2-Query" class="headerlink" title="2.@Query"></a>2.@Query</h4><ol>
<li><p>@Query不仅仅可以查询，也可以进行增删改的操作</p>
</li>
<li><p>查询操作直接使用@Query就可以,增删改操作需要添加@Modifying以及在事务环境下运行，可以直接添加 @Transactional。</p>
</li>
<li><p>@Query查询同样可以使用Sort，Pageable对象进行分页排序</p>
</li>
<li><p>@Query可以使用 JPQL,原生sql,SpEL表达式</p>
</li>
<li><p><strong>JPQL</strong></p>
<p> JPQL就是一种查询语言，具有与 SQL 相类似的特征， JPQL 是完全面向对象的，具备继承、多态和关联等特性，和hibernate HQL很相似。</p>
<p> JPQL 语句支持两种方式的参数定义方式 : 命名参数和位置参数 。在同一个查询语句中只允许使用一种参数定义方式。</p>
<p> 命令参数的格式为： : + 参数名 ,命令参数一般需要使用@Param来定义参数名</p>
<p> 位置参数的格式为: ?+ 位置编号</p>
</li>
</ol>
<ol start="4">
<li><p><strong>原生sql</strong></p>
<p> jpa也可以使用原生sql,但是需要在@Query 中添加nativeQuery = true的参数</p>
<p> 而且，使用原声sql无法分页，所以需要添加如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Query(value &#x3D; &quot;SELECT * FROM USERS WHERE LASTNAME &#x3D; ?1&quot;,</span><br><span class="line">  countQuery &#x3D; &quot;SELECT count(*) FROM USERS WHERE LASTNAME &#x3D; ?1&quot;,</span><br><span class="line">  nativeQuery &#x3D; true)</span><br><span class="line">Page&lt;User&gt; findByLastname(String lastname, Pageable pageable);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>SpEL表达式</strong></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5.1  从Spring Data JPA 1.4版本开始，支持在@Query定义的查询中使用SpEL模板表达式。在执行查询的时候，这些表达式通过一个事先定义好的变量集合求值。Spring Data JPA支持成为entityName的变量。它的用法是select x from #&#123;#entityName&#125; x。它会将域类型的entityName与给定repository关联起来。entityName按照如下方式处理：如果域类型在@Entity注解上设置了name属性，则使用该属性。否则直接使用域类型的类名。 </span><br><span class="line"></span><br><span class="line">5.2 一般使用是使用#&#123;#entityName&#125;代替实体名,这样你改动实体名，也不会对查询造成影响</span><br><span class="line"></span><br><span class="line">另一个#&#123;#entityName&#125;表达式的使用场景是如果你想定义一个通用的repository接口和一个用于具体域类型的指定repository接口。为了避免重复定义具体接口中的自定义查询方法，你可以在通用接口中使用实体名称表达式：</span><br><span class="line"></span><br><span class="line">我们系统来说，就可以使用这个定义一个关于sellerId 和 isdelete的通用查询接口。</span><br></pre></td></tr></table></figure>
<h4 id="3-Example"><a href="#3-Example" class="headerlink" title="3.Example"></a>3.Example</h4><ol>
<li><p>Example查询的组成</p>
<p> Probe: 含有对应字段的实例对象。</p>
<p> ExampleMatcher：ExampleMatcher携带有关如何匹配特定字段的详细信息，相当于匹配条件。设置包括 忽律，包含，为空，是否区分大小写,类型转换。</p>
<p> Example：由Probe和ExampleMatcher组成，用于查询。</p>
<p> 主要限制：<br>属性不支持嵌套或者分组约束，比如这样的查询 firstname = ?0 or (firstname = ?1 and lastname = ?2)<br>灵活匹配只支持字符串类型，其他类型只支持精确匹配，而且不支持in查询。</p>
</li>
<li><p>Example查询方式</p>
<pre><code> 1.组成查询实体
 Account account = new Account();
 account.setAge(1);
 account.setFirstName(&quot;li&quot;);
 2.组成匹配方式
 ExampleMatcher exampleMatcher = ExampleMatcher.matching().withMatcher(&quot;firstName&quot;,e-&gt;e.contains());
 3.组合example
 Example&lt;Account&gt; example = Example.of(account,exampleMatcher);
 4.如需要分页和排序，则创建分页和排序
 Sort sort = new Sort(Sort.Direction.DESC,&quot;age&quot;);
 PageRequest pageRequest = PageRequest.of(0,1,sort);
 5.查询
 Page&lt;Account&gt; all1 = repository.findAll(example, pageRequest);</code></pre>
</li>
</ol>
<h4 id="4-Specification"><a href="#4-Specification" class="headerlink" title="4.Specification"></a>4.Specification</h4><ol>
<li><p><strong>简介</strong></p>
<p> 由DDD之父 Eric Evans 和OO之父 Martin Fowler定义的Specification(规格模式)。Spring Data JPA已经帮助我们很大程度上简化了我们的查询操作，我们甚至只要写一个接口，然后单纯的写一些方法就可以完成各式各样的查询，但是对于我们程序设计人员而言，总希望所有的查询变得更加的简单方便，为了给程序人员进行再一次的封装，Spring Data JPA提供了Specification的方式进行查询。</p>
</li>
</ol>
<h4 id="5-querydsl"><a href="#5-querydsl" class="headerlink" title="5.querydsl"></a>5.querydsl</h4><ol>
<li><p><strong>简介</strong></p>
<p>  如果说Hibernate等ORM是JPA的实现，而SpringDataJPA是对JPA使用的封装，那么QueryDSL可以是与SpringDataJPA有着同阶层的级别，它也是基于各种ORM之上的一个通用查询框架，使用它的API类库可以写出“Java代码的sql”，不用去手动接触sql语句，表达含义却如sql般准确。更重要的一点，它能够构建类型安全的查询，这比起JPA使用原生查询时有很大的不同，我们可以不必再对恶心的“Object[]”进行操作了。当然，我们可以SpringDataJPA +QueryDSL.JPA联合使用，它们之间有着完美的相互支持，以达到更高效的编码。</p>
</li>
<li><p>就是生成了一个Q实体，使用这个Q实体，可以轻松的组合成各种个样的查询条件。</p>
</li>
</ol>
<h3 id="jpa使用实体做做参数"><a href="#jpa使用实体做做参数" class="headerlink" title="jpa使用实体做做参数"></a>jpa使用实体做做参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Modifying</span><br><span class="line">@Query(&quot;update CommunityEntity set status&#x3D; :#&#123;#entity.status&#125; ,statusGroup&#x3D; :#&#123;#entity.statusGroup&#125; where &quot; +</span><br><span class="line">&quot;communityId&#x3D; :#&#123;#entity.communityId&#125; and sellerId&#x3D; :#&#123;#entity.sellerId&#125;  and isDeleted&#x3D; :#&#123;#entity.isDeleted&#125;&quot;)</span><br><span class="line">int updateCommunityStatus(@Param(&quot;entity&quot;) CommunityEntity entity);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.rcode.top/2021/02/13/netty/netty/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://z3.ax1x.com/2021/05/30/2VQ8M9.jpg">
      <meta itemprop="name" content="河神">
      <meta itemprop="description" content="你可以跑,但你不能躲">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rick-Code">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/13/netty/netty/" class="post-title-link" itemprop="url">网络通信原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-13 19:49:31" itemprop="dateCreated datePublished" datetime="2021-02-13T19:49:31+08:00">2021-02-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-30 17:14:36" itemprop="dateModified" datetime="2021-05-30T17:14:36+08:00">2021-05-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/netty/" itemprop="url" rel="index"><span itemprop="name">netty</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <table>
<thead>
<tr>
<th align="center">TCP/IP</th>
<th align="center">TCP/IP</th>
<th align="center">OSI</th>
<th align="center">内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">应用层</td>
<td align="center">应用层</td>
<td align="center">应用层</td>
<td align="center">HTTP/FTP/POP3 等等应用协议</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">表示层</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">会话层</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">传输层</td>
<td align="center">传输层</td>
<td align="center">传输层</td>
<td align="center">TCP协议</td>
</tr>
<tr>
<td align="center">网络层</td>
<td align="center">网络层</td>
<td align="center">网络层</td>
<td align="center">IP协议</td>
</tr>
<tr>
<td align="center">网络接口层</td>
<td align="center">数据链路层</td>
<td align="center">数据链路层</td>
<td align="center">将0 1 信号进行组封装位数据包</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">物理层</td>
<td align="center">物理层</td>
<td align="center">基于电信号发送高低位信号</td>
</tr>
</tbody></table>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>客户端发起请求</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">client</th>
<th align="center"></th>
<th align="center">server</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">syn_send</td>
<td align="center">SYN=1   seq = x</td>
<td align="center">-&gt;</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">&lt;-</td>
<td align="center">SYN = 1   ACK=1    seq=y ack= x+1</td>
<td align="center">syn_recv</td>
</tr>
<tr>
<td align="center">连接成功</td>
<td align="center">ACK=1  ack = y+1</td>
<td align="center">-&gt;</td>
<td align="center"></td>
<td align="center">连接成功</td>
</tr>
</tbody></table>
<h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">写</th>
<th align="center"></th>
<th align="center">读</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">seq=x+1 ack=y+1</td>
<td align="center">-&gt;</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">&lt;-</td>
<td align="center">ack = x+2</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>任意一方发起</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">client</th>
<th align="center"></th>
<th align="center">server</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">fin_wait_1</td>
<td align="center">FIN=1 seq=u</td>
<td align="center">-&gt;</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">fin_wait_2</td>
<td align="center"></td>
<td align="center">&lt;-</td>
<td align="center">ACK=1 ack=u+1  seq=v</td>
<td align="center">close_wait</td>
</tr>
<tr>
<td align="center">time_walt</td>
<td align="center"></td>
<td align="center">&lt;-</td>
<td align="center">FIN =1 ACK=1 seq =w ack=u+1</td>
<td align="center">last_ack</td>
</tr>
<tr>
<td align="center">time_walt</td>
<td align="center">ACK=1 seq=u+1 ack=w+1</td>
<td align="center">-&gt;</td>
<td align="center"></td>
<td align="center">close()</td>
</tr>
</tbody></table>
<ol>
<li>客户端发起中断请求，FIN 请求，seq为(前面传送过来的最后一个数据字节+1)，意味着客户端没有数据发送了</li>
<li>此时返回一个ACK确认，表示收到了，但是服务端如果有数据需要发送，还是可以继续发送，客户端也需要接受。并且服务端进行等待关闭。客户端接口之后，进入终止等待2状态</li>
<li>当服务端的数据发送完成之后，服务端 发送FIN 请求，服务端进入最后确认状态</li>
<li>当客户端收到最后确认之后，发送确认消息，服务端收到后立即 进入CLOSE 状态。但是客户端此时还没有关闭，必须等待（2MSL）2倍最长报文寿命的时候，才能进入CLOSE状态 ，（可以设置不等待，直接关闭）</li>
</ol>
<h2 id="IO是什么"><a href="#IO是什么" class="headerlink" title="IO是什么"></a>IO是什么</h2><ol>
<li><p>对于Unix来说，一切皆文件，Socket,管道，FIFO,终端，都是文件，操作这些文件，就是IO操作</p>
</li>
<li><p> 文件描述符（FD）,文件描述符标识 文件流，让操作系统可以找到需要操作的流。</p>
<h2 id="用户空间-内核空间"><a href="#用户空间-内核空间" class="headerlink" title="用户空间/内核空间"></a>用户空间/内核空间</h2></li>
<li><p>内核空间存放的是内核代码 和 数据</p>
<ol>
<li>权限为0级</li>
</ol>
</li>
<li><p>用户空间存放的是用户代码 和 数据 </p>
<ol>
<li>权限为3级</li>
</ol>
</li>
</ol>
<h3 id="一般的网络操作为："><a href="#一般的网络操作为：" class="headerlink" title="一般的网络操作为："></a>一般的网络操作为：</h3><ol>
<li>等待数据到达网卡，然后将数据复制到内核缓冲区</li>
<li>从内核缓冲区复制数据，然后拷贝到用户空间</li>
</ol>
<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><ul>
<li>IO模型一般分为两个步骤，1 等待 2.数据复制<table>
<thead>
<tr>
<th>IO模型</th>
<th>特点</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>阻塞IO模型</td>
<td>在IO执行的两个阶段，都会被阻塞</td>
<td>1.阻塞进程不占用CPU</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<p>2.响应即时 | 1.需要为每一个请求分配一个线程，系统开销大，不适合大并发 |<br>| 非阻塞IO模型 | 第一阶段不阻塞，由阻塞变为不断的轮询<br>第二阶段阻塞 |  | 1.需要不断轮询，CPU消耗大，适合<br>2.需要为每一个请求分配一个线程，系统开销大，不适合大并发<br>3.响应不及时 |<br>| 多路复用IO模型 | 第一阶段，多个进程的I/O注册到一个复用器（Selector）上面，当没有数据的时候Selector阻塞，当有数据的时候，会返回数据。</p>
<p>第二阶段阻塞 | 1.多个请求可以由一个线程进行管理，节省CPU 和 系统消耗。<br>2.适合高并发应用，性能好 | 开发难度大 |<br>| 信号驱动IO模型 | 第一阶段由系统通过注册的信号来通知用户进程，是非阻塞的</p>
<p>第二阶段阻塞 | 应用场景少 |  |<br>| 异步IO模型 | 第一阶段 第二阶段 都不阻塞，一步完成后通知通知应用程序 | JAVA的aio就是这样 |  |</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.rcode.top/2021/01/25/spring/spring%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://z3.ax1x.com/2021/05/30/2VQ8M9.jpg">
      <meta itemprop="name" content="河神">
      <meta itemprop="description" content="你可以跑,但你不能躲">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rick-Code">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/25/spring/spring%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Springboot自动装配</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-25 00:00:00" itemprop="dateCreated datePublished" datetime="2021-01-25T00:00:00+08:00">2021-01-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-27 01:01:07" itemprop="dateModified" datetime="2021-01-27T01:01:07+08:00">2021-01-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Spring的事件监听是通过注册在ApplicationContext的  ApplicationEvent 和 ApplicationListener 提供的。将ApplicationListener 注册在ApplicationContext后。通过ApplicationEventPublisher发布事件后，都会通知到ApplicationListener 中。实际上，这就是标准的观察者模式(Observer)。</p>
<p>##在Spring中，默认已经实现了6种标准的事件</p>
<h4 id="ContextRefreshedEvent"><a href="#ContextRefreshedEvent" class="headerlink" title="ContextRefreshedEvent"></a>ContextRefreshedEvent</h4><p>在ApplicationContext初始化以及刷新的时候会发布ContextRefreshedEvent事件,例如，ConfigurableApplicationContext在执行refresh()方法的时候，就会发布事件，对于ApplicationContext来说，只要上下文没有关闭，并且可以执行热刷新的操作，就可以重复触发这个事件。初始化完成，意味着加载完成所有的bean,并且执行了后处理方法,并且ApplicationContext对象可用。 例如，XmlWebApplicationContext支持热刷新，但GenericApplicationContext，AnnotationConfigApplicationContext不支持</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">	@Override</span><br><span class="line">	public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">		synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">				.....</span><br><span class="line"></span><br><span class="line">                                 &#x2F;&#x2F;在这里检查所有添加到ApplicationContext的监听器，并且注册</span><br><span class="line">				&#x2F;&#x2F; Check for listener beans and register them.</span><br><span class="line">				registerListeners();</span><br><span class="line">                                .... </span><br><span class="line">              </span><br><span class="line">				&#x2F;&#x2F; Last step: publish corresponding event.</span><br><span class="line">				finishRefresh();</span><br><span class="line">			&#125;</span><br><span class="line">                            ....</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">在finishRefresh（）中</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Finish the refresh of this context, invoking the LifecycleProcessor&#39;s</span><br><span class="line">	 * onRefresh() method and publishing the</span><br><span class="line">	 * &#123;@link org.springframework.context.event.ContextRefreshedEvent&#125;.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	protected void finishRefresh() &#123;</span><br><span class="line">		&#x2F;&#x2F; Clear context-level resource caches (such as ASM metadata from scanning).</span><br><span class="line">		clearResourceCaches();</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; Initialize lifecycle processor for this context.</span><br><span class="line">		initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; Propagate refresh to lifecycle processor first.</span><br><span class="line">		getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; Publish the final event. &#x2F;&#x2F;在这里发布了刷新事件</span><br><span class="line">		publishEvent(new ContextRefreshedEvent(this));</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; Participate in LiveBeansView MBean, if active.</span><br><span class="line">		LiveBeansView.registerApplicationContext(this);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ContextStartedEvent"><a href="#ContextStartedEvent" class="headerlink" title="ContextStartedEvent"></a>ContextStartedEvent</h4><p>在ApplicationContext的start()方法执行后，会发布ContextStartedEvent事件，start()方法以为着所有的bean都会收到一个显示的信号，这个信号通常是重新启动停止的bean，或者没有自动启动的bean，<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void start() &#123;</span><br><span class="line">	getLifecycleProcessor().start();</span><br><span class="line">	publishEvent(new ContextStartedEvent(this));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="ContextStoppedEvent"><a href="#ContextStoppedEvent" class="headerlink" title="ContextStoppedEvent"></a>ContextStoppedEvent</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void stop() &#123;</span><br><span class="line">	getLifecycleProcessor().stop();</span><br><span class="line">	publishEvent(new ContextStoppedEvent(this));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ContextClosedEvent"><a href="#ContextClosedEvent" class="headerlink" title="ContextClosedEvent"></a>ContextClosedEvent</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">protected void doClose() &#123;</span><br><span class="line">        .....</span><br><span class="line">			try &#123;</span><br><span class="line">				&#x2F;&#x2F; Publish shutdown event.</span><br><span class="line">				publishEvent(new ContextClosedEvent(this));</span><br><span class="line">			&#125;</span><br><span class="line">			.....</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RequestHandledEvent"><a href="#RequestHandledEvent" class="headerlink" title="RequestHandledEvent"></a>RequestHandledEvent</h4><h4 id="ServletRequestHandledEvent"><a href="#ServletRequestHandledEvent" class="headerlink" title="ServletRequestHandledEvent"></a>ServletRequestHandledEvent</h4><h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><h3 id="使用ApplicationEvent来发布事件"><a href="#使用ApplicationEvent来发布事件" class="headerlink" title="使用ApplicationEvent来发布事件"></a>使用ApplicationEvent来发布事件</h3><p>首先定义1个继承与 ApplicationEvent 的对象实体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class CreateManger extends ApplicationEvent &#123;</span><br><span class="line">    private String data;</span><br><span class="line">    public CreateManger(ApplicationContext source,String data) &#123;</span><br><span class="line">        super(source);</span><br><span class="line">        this.data &#x3D; data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在定义1个监听器，用来监听事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class BaseListener implements ApplicationListener&lt;CreateManger&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(CreateManger event) &#123;</span><br><span class="line">        System.out.println(event.getData());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于Spring已经实现的事件，我们只需要添加监听器，不用添加监听对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class StartListener implements ApplicationListener&lt; ContextStartedEvent &gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(ContextStartedEvent event) &#123;</span><br><span class="line">        System.out.println(&quot;onApplicationEvent:&quot;+event.getTimestamp());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们再将监听器注册进我们的上下文中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class RegistryListener implements ApplicationContextAware &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        ConfigurableApplicationContext configurableApplicationContext &#x3D; (ConfigurableApplicationContext)applicationContext;</span><br><span class="line">        configurableApplicationContext.addApplicationListener(new BaseListener());</span><br><span class="line">        configurableApplicationContext.addApplicationListener(new StartListener());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再定义一个事件发布器，另外，也可以通过applicationContext上下文来直接发布事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Send implements ApplicationEventPublisherAware &#123;</span><br><span class="line">    public ApplicationEventPublisher publisher;</span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) &#123;</span><br><span class="line">        this.publisher &#x3D; applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void publish(ApplicationEvent event)&#123;</span><br><span class="line">        publisher.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void publish(Object event)&#123;</span><br><span class="line">        publisher.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，在我们的容器启动起来,执行start().或者发送CreateManger事件，就会在对应的监听器中监听变化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException, InterruptedException &#123;</span><br><span class="line">    AnnotationConfigApplicationContext applicationContext</span><br><span class="line">         &#x3D; new AnnotationConfigApplicationContext(&quot;con.note.config&quot;);</span><br><span class="line"></span><br><span class="line">    applicationContext.start();</span><br><span class="line">    Send send &#x3D; applicationContext.getBean(Send.class);</span><br><span class="line">    CreateManger createManger &#x3D; new CreateManger(applicationContext,&quot;mimi&quot;);</span><br><span class="line">    send.publish(createManger);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事件同样也支持异步的操作，但是在我们直接的编码中，这种会稍微麻烦一点，我这边的实现是在 SimpleApplicationEventMulticaster 对象生成后，对其的 TaskExecutor 进行注入，但是这种方式的话，会将所有的事件都变为异步，具体下面的源码解析会说到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SimpleApplicationEventMulticasterAware implements BeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">        if (bean instanceof SimpleApplicationEventMulticaster)&#123;</span><br><span class="line">            SimpleApplicationEventMulticaster simpleApplicationEventMulticaster &#x3D; (SimpleApplicationEventMulticaster)bean;</span><br><span class="line">            simpleApplicationEventMulticaster.setTaskExecutor(Executors.newFixedThreadPool(10));</span><br><span class="line">            return simpleApplicationEventMulticaster;</span><br><span class="line">        &#125;</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="使用注解来使用事件监听"><a href="#使用注解来使用事件监听" class="headerlink" title="使用注解来使用事件监听"></a>使用注解来使用事件监听</h4><p>使用注解来监听的话，整体流程相对于我们直接使用ApplicationEvent会方便一些，使用注解的话，我们不但可以监听继承于ApplicationEvent的对象，也可以监听任意Object对象</p>
<p>其主要通过 @EventListener 注解来监听事件，其原理下面会说到。其包括监听的对象，以及 condition，一个条件，对我们监听的事件进行过滤，其支持spel表达式。代码（4）</p>
<p>其中如果需要异步执行的话，只需要在方法加上@Async注解即可。（需要配合@EnableAsync使用）</p>
<p>对于多个监听器，可以使用 @Order(42) 来定义顺序</p>
<p>如果我们的方法是拥有返回值的，那么我们的当前事件处理完成之后，就会发布另一个事件,代码（3）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    @EventListener(value &#x3D; &#123;ContextClosedEvent.class, ContextStoppedEvent.class&#125;)</span><br><span class="line">    public void springListener(ApplicationContextEvent applicationContextEvent)&#123;</span><br><span class="line"></span><br><span class="line">        ApplicationContext applicationContext &#x3D; applicationContextEvent.getApplicationContext();</span><br><span class="line">        SimpleApplicationEventMulticaster bean &#x3D; applicationContext.getBean(SimpleApplicationEventMulticaster.class);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Async</span><br><span class="line">    @Order(42)</span><br><span class="line">    @EventListener(value &#x3D; &#123;CreateManger.class&#125;)</span><br><span class="line">    public void baseListener(CreateManger createManger) throws InterruptedException &#123;</span><br><span class="line">        Thread.sleep(1000L);</span><br><span class="line">        System.out.println(&quot;createManger---&gt;&quot;+createManger.getTimestamp());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">(3)</span><br><span class="line">    &#x2F;&#x2F;指定完了CreateManger 然后执行BuyManger </span><br><span class="line">    @EventListener(value &#x3D; &#123;CreateManger.class&#125;)</span><br><span class="line">    public BuyManger baseListener(CreateManger createManger) throws InterruptedException &#123;</span><br><span class="line">        Thread.sleep(1000L);</span><br><span class="line">        System.out.println(&quot;createManger---&gt;&quot;+createManger.getTimestamp());</span><br><span class="line">        return new BuyManger(&quot;测试&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">(4)其表示事件的属性等于test的时候，才会去执行</span><br><span class="line">    @EventListener(value &#x3D; &#123;CreateManger.class&#125;,condition &#x3D; &quot;#createManger.data &#x3D;&#x3D; &#39;test&#39;&quot;)</span><br><span class="line">    public BuyManger baseListener(CreateManger createManger) throws InterruptedException &#123;</span><br><span class="line">        Thread.sleep(1000L);</span><br><span class="line">        System.out.println(&quot;createManger---&gt;&quot;+createManger.getTimestamp());</span><br><span class="line">        return new BuyManger(&quot;测试&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="注册事件篇"><a href="#注册事件篇" class="headerlink" title="注册事件篇"></a>注册事件篇</h3><h3 id="使用ApplicationListener注册"><a href="#使用ApplicationListener注册" class="headerlink" title="使用ApplicationListener注册"></a>使用ApplicationListener注册</h3><h3 id="使用-EventListener注解注册"><a href="#使用-EventListener注解注册" class="headerlink" title="使用@EventListener注解注册"></a>使用@EventListener注解注册</h3><p>使用注解注册的时候，Spring会把方法包装成为ApplicationListenerMethodAdapter对象，然后注册在spring中</p>
<ol>
<li>在EventListenerMethodProcessor 对象中<br>这个对象实现了 SmartInitializingSingleton 接口，其中的 afterSingletonsInstantiated()方法；是在所有bean初始化完成之后调用的，<br>其中的核心方法在于 processBean，最终在这个方法，将方法信息，源配置类，包装成 ApplicationListenerMethodAdapter 对象，在之后通过反射进行调用<br>同时，最终也是通过 context.addApplicationListener()注册到上下文中</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private void processBean(final String beanName, final Class&lt;?&gt; targetType) &#123;</span><br><span class="line">		if (!this.nonAnnotatedClasses.contains(targetType) &amp;&amp;</span><br><span class="line">				AnnotationUtils.isCandidateClass(targetType, EventListener.class) &amp;&amp;</span><br><span class="line">				!isSpringContainerClass(targetType)) &#123;</span><br><span class="line"></span><br><span class="line">			Map&lt;Method, EventListener&gt; annotatedMethods &#x3D; null;</span><br><span class="line">			try &#123;</span><br><span class="line">				annotatedMethods &#x3D; MethodIntrospector.selectMethods(targetType,</span><br><span class="line">						(MethodIntrospector.MetadataLookup&lt;EventListener&gt;) method -&gt;</span><br><span class="line">								AnnotatedElementUtils.findMergedAnnotation(method, EventListener.class));</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Throwable ex) &#123;...&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				&#x2F;&#x2F; Non-empty set of methods</span><br><span class="line">				ConfigurableApplicationContext context &#x3D; this.applicationContext;</span><br><span class="line">				Assert.state(context !&#x3D; null, &quot;No ApplicationContext set&quot;);</span><br><span class="line">				List&lt;EventListenerFactory&gt; factories &#x3D; this.eventListenerFactories;</span><br><span class="line">				Assert.state(factories !&#x3D; null, &quot;EventListenerFactory List not initialized&quot;);</span><br><span class="line">				for (Method method : annotatedMethods.keySet()) &#123;</span><br><span class="line">					for (EventListenerFactory factory : factories) &#123;</span><br><span class="line">						if (factory.supportsMethod(method)) &#123;</span><br><span class="line">							Method methodToUse &#x3D; AopUtils.selectInvocableMethod(method, context.getType(beanName));</span><br><span class="line">							&#x2F;&#x2F;最终在这个方法，将方法信息，源配置类，包装成 ApplicationListenerMethodAdapter 对象，在之后通过反射进行调用</span><br><span class="line">							ApplicationListener&lt;?&gt; applicationListener &#x3D;</span><br><span class="line">									factory.createApplicationListener(beanName, targetType, methodToUse);</span><br><span class="line">							if (applicationListener instanceof ApplicationListenerMethodAdapter) &#123;</span><br><span class="line">								((ApplicationListenerMethodAdapter) applicationListener).init(context, this.evaluator);</span><br><span class="line">							&#125;</span><br><span class="line">							context.addApplicationListener(applicationListener);</span><br><span class="line">							break;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				if (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(annotatedMethods.size() + &quot; @EventListener methods processed on bean &#39;&quot; +</span><br><span class="line">							beanName + &quot;&#39;: &quot; + annotatedMethods);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>ApplicationListenerMethodAdapter的构造函数中可以看到，将@EventListener的注解中的 condition，order，参数 等等都封装起来，供事件触发调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public ApplicationListenerMethodAdapter(String beanName, Class&lt;?&gt; targetClass, Method method) &#123;</span><br><span class="line">	this.beanName &#x3D; beanName;</span><br><span class="line">	this.method &#x3D; BridgeMethodResolver.findBridgedMethod(method);</span><br><span class="line">	this.targetMethod &#x3D; (!Proxy.isProxyClass(targetClass) ?</span><br><span class="line">			AopUtils.getMostSpecificMethod(method, targetClass) : this.method);</span><br><span class="line">	this.methodKey &#x3D; new AnnotatedElementKey(this.targetMethod, targetClass);</span><br><span class="line"></span><br><span class="line">	EventListener ann &#x3D; AnnotatedElementUtils.findMergedAnnotation(this.targetMethod, EventListener.class);</span><br><span class="line">	this.declaredEventTypes &#x3D; resolveDeclaredEventTypes(method, ann);</span><br><span class="line">	this.condition &#x3D; (ann !&#x3D; null ? ann.condition() : null);</span><br><span class="line">	this.order &#x3D; resolveOrder(this.targetMethod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="publishEvent的实现"><a href="#publishEvent的实现" class="headerlink" title="publishEvent的实现"></a>publishEvent的实现</h4><ol>
<li>首先判断事件的类型是直接继承ApplicationEvent的，还是Object类型的事件， 上面说过，事件可以直接发布对象</li>
<li>在这里会做一个判断，如果是在监听器初始化完成之前发布的事件，就在这里先放入earlyApplicationEvents中，如果初始化完成的，就直接调用multicastEvent来执行</li>
<li>如果当前命名空间还有父亲节点，也需要给父亲推送该消息</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">protected void publishEvent(Object event, @Nullable ResolvableType eventType) &#123;</span><br><span class="line">		Assert.notNull(event, &quot;Event must not be null&quot;);</span><br><span class="line">1. 首先判断事件的类型是直接继承ApplicationEvent的，还是Object类型的事件， 上面说过，事件可以直接发布对象</span><br><span class="line">		&#x2F;&#x2F; Decorate event as an ApplicationEvent if necessary</span><br><span class="line">		ApplicationEvent applicationEvent;</span><br><span class="line">		if (event instanceof ApplicationEvent) &#123;</span><br><span class="line">			applicationEvent &#x3D; (ApplicationEvent) event;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			applicationEvent &#x3D; new PayloadApplicationEvent&lt;&gt;(this, event);</span><br><span class="line">			if (eventType &#x3D;&#x3D; null) &#123;</span><br><span class="line">				eventType &#x3D; ((PayloadApplicationEvent&lt;?&gt;) applicationEvent).getResolvableType();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; Multicast right now if possible - or lazily once the multicaster is initialized</span><br><span class="line">		if (this.earlyApplicationEvents !&#x3D; null) &#123;</span><br><span class="line">			this.earlyApplicationEvents.add(applicationEvent);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; Publish event via parent context as well...</span><br><span class="line">		if (this.parent !&#x3D; null) &#123;</span><br><span class="line">			if (this.parent instanceof AbstractApplicationContext) &#123;</span><br><span class="line">				((AbstractApplicationContext) this.parent).publishEvent(event, eventType);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				this.parent.publishEvent(event);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="multicastEvent"><a href="#multicastEvent" class="headerlink" title="multicastEvent"></a>multicastEvent</h4><p>这里就是之前异步的时候配置的线程池的用处</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) &#123;</span><br><span class="line">	ResolvableType type &#x3D; (eventType !&#x3D; null ? eventType : resolveDefaultEventType(event));</span><br><span class="line">	Executor executor &#x3D; getTaskExecutor();</span><br><span class="line">	for (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">		if (executor !&#x3D; null) &#123;</span><br><span class="line">                               &#x2F;&#x2F;异步执行</span><br><span class="line">			executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">                               &#x2F;&#x2F;同步执行</span><br><span class="line">			invokeListener(listener, event);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="invokeListener-doInvokeListener"><a href="#invokeListener-doInvokeListener" class="headerlink" title="invokeListener#doInvokeListener"></a>invokeListener#doInvokeListener</h4><p>最终 是通过各个监听器的onApplicationEvent 来执行事件监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void doInvokeListener(ApplicationListener listener, ApplicationEvent event) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			listener.onApplicationEvent(event);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (ClassCastException ex) &#123;</span><br><span class="line">			....</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>而注解配置的监听器最终通过反射来执行方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void processEvent(ApplicationEvent event) &#123;</span><br><span class="line">	Object[] args &#x3D; resolveArguments(event);</span><br><span class="line">	if (shouldHandle(event, args)) &#123;</span><br><span class="line">                       &#x2F;&#x2F;最终这里通过代理执行事件方法</span><br><span class="line">		Object result &#x3D; doInvoke(args);</span><br><span class="line">		if (result !&#x3D; null) &#123;  </span><br><span class="line">                                 如果返回值不为空，判断是否是需要再次发布事件，就是方法的返回值的用处</span><br><span class="line">			handleResult(result);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			logger.trace(&quot;No result object given - no result to handle&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<hr>
<p>spring文档位置：<br><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#spring-core">https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#spring-core</a><br>1.15.2. Standard and Custom Events</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.rcode.top/2021/01/17/spring/SoringBean%E4%BB%8E%E5%A4%B4%E8%AF%B4%E5%88%B0%E5%B0%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://z3.ax1x.com/2021/05/30/2VQ8M9.jpg">
      <meta itemprop="name" content="河神">
      <meta itemprop="description" content="你可以跑,但你不能躲">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rick-Code">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/17/spring/SoringBean%E4%BB%8E%E5%A4%B4%E8%AF%B4%E5%88%B0%E5%B0%BE/" class="post-title-link" itemprop="url">SoringBean从头说到尾</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-17 17:03:03" itemprop="dateCreated datePublished" datetime="2021-01-17T17:03:03+08:00">2021-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-18 09:27:44" itemprop="dateModified" datetime="2021-01-18T09:27:44+08:00">2021-01-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.rcode.top/2021/01/17/dubbo/Dubbo%E4%BB%8E%E5%A4%B4%E8%AF%B4%E5%88%B0%E5%B0%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://z3.ax1x.com/2021/05/30/2VQ8M9.jpg">
      <meta itemprop="name" content="河神">
      <meta itemprop="description" content="你可以跑,但你不能躲">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rick-Code">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/17/dubbo/Dubbo%E4%BB%8E%E5%A4%B4%E8%AF%B4%E5%88%B0%E5%B0%BE/" class="post-title-link" itemprop="url">Dubbo从头说到尾</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-17 17:02:52 / 修改时间：17:03:14" itemprop="dateCreated datePublished" datetime="2021-01-17T17:02:52+08:00">2021-01-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="河神"
      src="https://z3.ax1x.com/2021/05/30/2VQ8M9.jpg">
  <p class="site-author-name" itemprop="name">河神</p>
  <div class="site-description" itemprop="description">你可以跑,但你不能躲</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.jianshu.com/u/40227ed13cdc" title="https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;40227ed13cdc" rel="noopener" target="_blank">简书</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">河神</span>
</div>


<a class="theme-link" target="_blank" href="https://www.jianshu.com/u/40227ed13cdc">桃花深处有人家</a>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script>
    <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/canvas_lines.min.js"></script>


  















  

  


  <script type="text/javascript" src="/js/click.js"></script>

</body>
</html>
